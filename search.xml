<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/13/Hello/</url>
    <content><![CDATA[<p>Here’s my first BLOG<br>So let’s say</p>
<p><strong>Hello World!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Image test</title>
    <url>/2023/09/14/Image-test/</url>
    <content><![CDATA[<p>Try to post a pic</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test-pic.png"
                      class="" title="test1"
                >

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test2.jpeg"
                      alt="test-pic2" title="test2"
                ><figcaption>test-pic2</figcaption></figure></p>
<p>Test end</p>
]]></content>
      <categories>
        <category>Function Test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程日志 Week1</title>
    <url>/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/</url>
    <content><![CDATA[<p>这次实验要求所有源码不得外传和共享，因此在博客里就不再给出源码了。</p>
<h2 id="实验概要"><a href="#实验概要" class="headerlink" title="实验概要"></a>实验概要</h2><p>第一周需要实现一个简单的echo web server模块，可以对传入的消息进行解析，判断其合法性，并按消息的不同类别进行响应。<br>对于具体的消息解析部分，利用Lex&amp;Yacc分词方法进行词法分析，以此解析出HTTP请求的种类。</p>
<h2 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h2><p>这次实验所要实现的功能比较简单，不需要额外设计数据结构来辅助实现。因此在数据结构部分主要描述在设计中使用到的数据结构以及对某些重要数据结构的分析。</p>
<h3 id="协议头结构"><a href="#协议头结构" class="headerlink" title="协议头结构"></a>协议头结构</h3><h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>在最初环境部署的阶段中，曾使用过<code>example</code>程序测试过对<code>/samples/sample_request_example</code>文件中HTTP请求的响应。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>sample_request_example</span></figcaption><table><tr><td class="code"><pre><span class="line">GET /~prs/15-441-F15/ HTTP/1.1</span><br><span class="line">Host: www.cs.cmu.edu</span><br></pre></td></tr></table></figure></div>
<p>可以看到，该文件的输入只包含了一行HTTP请求行和一行HTTP请求头部。在此情况下，框架代码能够正确识别并处理这一HTTP请求。但在实际情况中，HTTP请求包含多行请求头部，因此需要在后续的词法分析设计中保证程序可以处理多行请求头部的语法规则匹配。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/HTTPRequest.jpeg"
                      alt="HTTP Request" title="HTTP 请求报文结构"
                ><figcaption>HTTP Request</figcaption></figure><br>而对于Yacc解析出的数据，它通过一个特殊的数据结构Request来存储，该结构定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>Request</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/parse.h</span></span><br><span class="line"><span class="comment">// HTTP Request Header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> http_version[<span class="number">50</span>];</span><br><span class="line">	<span class="type">char</span> http_method[<span class="number">50</span>];</span><br><span class="line">	<span class="type">char</span> http_uri[<span class="number">4096</span>];</span><br><span class="line">	Request_header *headers;</span><br><span class="line">	<span class="type">int</span> header_count;</span><br><span class="line">&#125; Request;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，<code>http_version</code>、<code>http_version</code>和<code>http_version</code>将会分别存储HTTP请求行中的协议版本，请求方法和请求URI。而HTTP请求头部则被存储在一个<code>Request_header</code>结构的数组中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>Request_header</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/parse.h</span></span><br><span class="line"><span class="comment">// Header field</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> header_name[<span class="number">4096</span>];</span><br><span class="line">	<span class="type">char</span> header_value[<span class="number">4096</span>];</span><br><span class="line">&#125; Request_header;</span><br></pre></td></tr></table></figure></div>
<p>在<code>Request_header</code>中则会存储HTTP请求头部的头部字段名和值。<br>根据以上数据结构，我们可以更好的对解析后结果进行分类匹配并响应。</p>
<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>对于解析后的HTTP请求消息，共分为三种情况处理：</p>

  <div class="note-large green">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>GET&#x2F;HEAD&#x2F;POST</p>

    </div>
    <div class="notel-content">
      <p>当解析后发现消息为合法HTTP请求，且方法为GET&#x2F;HEAD&#x2F;POST，为已实现的方法，此时将消息进行重新封装，并直接发送回客户端。</p>

    </div>
  </div>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>Not-Implemented</p>

    </div>
    <div class="notel-content">
      <p>当解析后发现消息为合法的HTTP请求，但该消息请求的方法并未实现时，向客户端发送<code>&quot;HTTP/1.1 501 Not Implemented\r\n\r\n&quot;</code>。</p>

    </div>
  </div>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>Bad-Request</p>

    </div>
    <div class="notel-content">
      <p>当解析过程中发现消息格式错误，为非法消息时，向客户端发送<code>&quot;HTTP/1.1 400 Bad request\r\n\r\n&quot;</code>。</p>

    </div>
  </div>
<p>在词法分析模块将输入消息进行解析后，将缓冲区中的解析结果与上述情况进行一一匹配，便能得到正确的响应。随后再根据上述要求进行响应即可。</p>
<h3 id="Lex-Yacc词法分析结构"><a href="#Lex-Yacc词法分析结构" class="headerlink" title="Lex&amp;Yacc词法分析结构"></a>Lex&amp;Yacc词法分析结构</h3><h5 id="数据结构设计-1"><a href="#数据结构设计-1" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>总体来说，Lex&amp;Yacc词法分析的框架是：Lex先扫描每个输入的字符串，按预先设定的种类对字符串进行匹配，并将其替换为该种类的标签符。<br>随后，Yacc扫描Lex处理后得到的标签串，根据实现定义的语法规则对标签串进行规约匹配，得到规约后的输出结果。</p>
<h5 id="协议规则设计-1"><a href="#协议规则设计-1" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>在查看Yacc规约规则的源码<code>/src/parser.y</code>后，发现其中已经定义了用于识别HTTP请求行的规则<code>request_line</code>，和用于识别HTTP请求头部的规则<code>request_header</code>。仔细阅读后，发现已有的语法规则只能成功识别一行HTTP请求头部，这与实验要求不符，因此需要设计可识别多行请求头部的语法规则。<br>由于对于每行请求头部，它所遵循的语法规则都是相同的，且与单行请求头部的规则一致，因此使用递归的方式就能很好的完成多行识别，这在某些已有规则的定义中也有所体现。<br>由此，只需先对第一行按单行请求头部的语法规则进行匹配，再递归的对后续输入尝试用此规则进行匹配即可。</p>
<h2 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h2><h3 id="客户端输入模块"><a href="#客户端输入模块" class="headerlink" title="客户端输入模块"></a>客户端输入模块</h3><p>首先，在最初的环境配置阶段，以及阅读源码后可知，<code>echo_client</code>程序目前通过命令行输入的方式来读取输入，而<code>example</code>程序则可以通过文件来获取输入。因此，我们首先需要将<code>echo_client</code>更改为通过文件输入。这一部分的实现较为简单，只需参照<code>/src/example.c</code>中的代码实现即可，并注意在读取参数表时加入一项输入文件的路径。</p>
<h3 id="词法分析模块"><a href="#词法分析模块" class="headerlink" title="词法分析模块"></a>词法分析模块</h3><p>在前面的设计部分提到过，通过递归的方式设计语法规则就可以很好的完成对多行请求头部的匹配。具体而言，在Yacc中，通过逻辑连接词<code>｜</code>就可以实现递归匹配。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>Rules_Rec</span></figcaption><table><tr><td class="code"><pre><span class="line">rules_rec: rules &#123;</span><br><span class="line">    body1;</span><br><span class="line">&#125;; |</span><br><span class="line">rules_rec &#123;</span><br><span class="line">    body2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>如上伪代码给出了一种递归语法规则<code>rules_rec</code>的定义方式。其中，<code>rules</code>是对单行定义的语法规则，而在<code>rules_rec</code>匹配时，会尝试匹配一个<code>rules</code>或是一个<code>rules_rec</code>，这就形成了递归调用，以此可以根据一个语法规则对多行中的每行都按<code>rules</code>规则进行匹配。<br>由于在框架代码中，对于单行HTTP请求头部的语法规则<code>request_header</code>已经定义，因此只需在<code>/src/parser.y</code>参照上面给出的定义方式，定义递归匹配多行的语法规则<code>request_header_rec</code>，并使用此规则进行匹配即可。<br>此外，前面提到过，<code>/src/parser.c</code>会将解析完毕的HTTP请求存储在<code>Request -&gt; headers</code>中，而在框架代码中，由于只进行一行的请求头部解析，所以程序只为<code>Request -&gt; headers</code>申请了一个元素的空间。因此还需增加程序为<code>Request -&gt; headers</code>申请的空间大小，以存储全部的HTTP请求头部信息。在这次实验中，我们将空间大小设为64行，应该可以顺利实现实验所要求的功能。</p>
<h3 id="服务器响应模块"><a href="#服务器响应模块" class="headerlink" title="服务器响应模块"></a>服务器响应模块</h3><p>服务器响应模块应在<code>/src/echo_server.c</code>中实现。在服务器响应部分中，已有的框架代码会从客户端接收请求消息，将其存储至缓冲区<code>buf</code>中，并直接发送回客户端。因此，需要为其加入词法分析和对应响应功能。首先，利用在<code>/src/parser.h</code>中定义的<code>parser</code>函数，将<code>buf</code>中的内容使用词法分析模块进行解析，并将解析结果存储在专门的数据结构<code>Request</code>中。随后，可以对解析结果进行判断。在解析失败时，<code>request</code>应为空，此时返回400报错；否则解析成功，此时判断<code>request -&gt; http_method</code>是否为<code>&quot;GET&quot;\&quot;HEAD&quot;\&quot;POST&quot;</code>，若字符串比对成功，则应将解析后的消息复制至缓冲区中，并直接发送回客户端；否则，则代表请求为未实现的HTTP方法，此时返回501报错。此外，在对解析后消息进行匹配和响应时，会涉及到对缓冲区的匹配识别和修改问题。因此可以提前定义一些用于匹配和填充的字符串，用以更便捷和安全的操作缓冲区。同时，在每次发送响应时还应检查发送是否成功，此部分代码在框架代码中已经给出。由此可以写出响应模块的伪代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Response</span></figcaption><table><tr><td class="code"><pre><span class="line">IF request IS NULL</span><br><span class="line">    THEN SEND ERROR 400</span><br><span class="line">        CHECK SEND</span><br><span class="line">ELSE IF request -&gt; http_method IS &quot;GET&quot;</span><br><span class="line">        OR IS &quot;HEAD&quot; OR IS &quot;POST&quot;</span><br><span class="line">    THEN COPY request TO buf </span><br><span class="line">        SEND buf</span><br><span class="line">        CHECK SEND</span><br><span class="line">ELSE</span><br><span class="line">    THEN SEND ERROR 501</span><br><span class="line">        CHECK SEND</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure></div>
<h3 id="缓冲区清除"><a href="#缓冲区清除" class="headerlink" title="缓冲区清除"></a>缓冲区清除</h3><p>在每完成一个HTTP请求信息的解析和响应后，为避免上一次的消息影响对下一次消息的解析和响应结果，我们需要对解析结果<code>request</code>和缓冲区都进行清空。这一部分很容易就可以在<code>/src/echo_server.c</code>进行实现。但在一次测试中，发现如果先传输一个格式错误，响应ERROR 400的HTTP请求，再传输格式正确的HTTP请求，程序依然会判断该消息格式错误，响应ERROR 400。经过检查，发现此时<code>request</code>为空，即错误出现在词法分析模块。仔细检查测试中的输出可以发现，在输入格式正确的HTTP请求后词法分析模块进行匹配的字符串并非新输入的字符串，而是前面格式错误输入文件的后续部分。因此可以断定出现此问题的原因是词法分析模块存在未被清空的缓冲区。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/Debug.jpeg"
                      alt="Wrong Output Log" title="错误部分的详细输出"
                ><figcaption>Wrong Output Log</figcaption></figure><br>于是再度深入语法分析模块进行检查，最终发现是Lex在进行匹配时存在隐藏的队列结构的缓冲区（<code>/src/lex.yy.c</code>），这会导致每次产生解析错误后，其后续消息会被作为下一次消息解析的开头，进而再次导致解析错误。不过，框架代码中也已经定义了用于清除该隐藏缓冲区的函数<code>yylex_destroy</code>，因此只需在<code>/src/parser.c</code>文件中，开始进行语法分析前调用上述函数，清空Lex的隐藏缓冲区即可。随后再次测试即可得到正确的结果。</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>在结果测试部分，分别进行了如下测试：</p>
<h5 id="GET-HEAD-POST请求"><a href="#GET-HEAD-POST请求" class="headerlink" title="GET&#x2F;HEAD&#x2F;POST请求"></a>GET&#x2F;HEAD&#x2F;POST请求</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/get.jpeg"
                      alt="HTTP GET" title="HTTP GET请求"
                ><figcaption>HTTP GET</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/head.jpeg"
                      alt="HTTP HEAD" title="HTTP HEAD请求"
                ><figcaption>HTTP HEAD</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/post.jpeg"
                      alt="HTTP POST" title="HTTP POST请求"
                ><figcaption>HTTP POST</figcaption></figure></p>
<h5 id="未实现方法PUT-WRONG"><a href="#未实现方法PUT-WRONG" class="headerlink" title="未实现方法PUT&#x2F;WRONG"></a>未实现方法PUT&#x2F;WRONG</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/501_put.jpeg"
                      alt="501 PUT" title="501报错 PUT"
                ><figcaption>501 PUT</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/501_wrong.jpeg"
                      alt="501 WRONG" title="501报错 WRONG"
                ><figcaption>501 WRONG</figcaption></figure></p>
<h5 id="6种格式错误"><a href="#6种格式错误" class="headerlink" title="6种格式错误"></a>6种格式错误</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_1.jpeg"
                      alt="400 1" title="400报错 1"
                ><figcaption>400 1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_2.jpeg"
                      alt="400 2" title="400报错 2"
                ><figcaption>400 2</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_3.jpeg"
                      alt="400 3" title="400报错 3"
                ><figcaption>400 3</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_4.jpeg"
                      alt="400 4" title="400报错 4"
                ><figcaption>400 4</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_5.jpeg"
                      alt="400 5" title="400报错 5"
                ><figcaption>400 5</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_6.jpeg"
                      alt="400 6" title="400报错 6"
                ><figcaption>400 6</figcaption></figure></p>
<h5 id="Autolab测试"><a href="#Autolab测试" class="headerlink" title="Autolab测试"></a>Autolab测试</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/autolab.jpeg"
                      alt="Autolab" title="Autolab 自动测试结果"
                ><figcaption>Autolab</figcaption></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>大概了解了一下实验环境，学了点正则表达式相关的知识和运用。明白了框架代码中服务器和客户端是如何通过socket进行通信的，以及源码的一些数据结构和程序框架，算是一个简单的入门。</p>
]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程记录-Week2</title>
    <url>/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/</url>
    <content><![CDATA[<h2 id="一、实验概要"><a href="#一、实验概要" class="headerlink" title="一、实验概要"></a>一、实验概要</h2><p>第二周需要实现的功能模块主要有以下几部分。</p>

  <div class="note-large green">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>请求响应模块</p>

    </div>
    <div class="notel-content">
      <p>1.正确响应GET&#x2F;HEAD&#x2F;POST请求，并能建立持久连接<br>2.支持四种错误代码：400，404，501，505<br>3.妥善管理缓冲区，避免缓冲区溢出错误</p>

    </div>
  </div>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>文件错误处理模块</p>

    </div>
    <div class="notel-content">
      <p>1.能够处理文件读写过程中遇到的错误，如权限问题、文件不存在、IO错误等</p>

    </div>
  </div>

  <div class="note-large yellow">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>日志模块</p>

    </div>
    <div class="notel-content">
      <p>1.按“Error Log”格式记录服务器的出错情况<br>2.按“Access Log”的“Common Log Format”格式记录服务器处理的请求<br>3.其它辅助调试的日志记录（不做格式要求）</p>

    </div>
  </div>

<h2 id="二、协议设计"><a href="#二、协议设计" class="headerlink" title="二、协议设计"></a>二、协议设计</h2><h3 id="1-响应生成模块"><a href="#1-响应生成模块" class="headerlink" title="1. 响应生成模块"></a>1. 响应生成模块</h3><p>首先，需要实现对GET、HEAD、POST三种请求的响应生成。</p>
<h4 id="GET响应生成"><a href="#GET响应生成" class="headerlink" title="GET响应生成"></a>GET响应生成</h4><h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><ol>
<li><p>响应数据结构<br>为了实现HTTP GET响应，首先需要了解正确的响应结构是什么样的。如下所示是需要实现的HTTP GET响应结构示意图。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/answer_format.jpeg"
                      alt="GET Answer" title="HTTP GET响应结构"
                ><figcaption>GET Answer</figcaption></figure><br>根据手册要求，响应中必须包含<code>&quot;HTTP/1.1 200 OK\r\n&quot;</code>，而响应实体部分则需从请求文件中获取。因此可以定义响应的结构为一个字符串，具体组成如下。<br><code>&quot;HTTP/1.1 200 OK\r\n&quot; + Data_in_file</code><br>此外，根据手册要求，缓冲区大小应设为<code>8192</code>。</p>
</li>
<li><p>文件状态结构<br>根据手册提示，使用<code>stat</code>函数来获取文件状态，并以此检测文件权限、大小等信息，处理可能产生的文件读写错误。而<code>stat</code>的返回值为一个自定义结构<code>struct stat</code>，该结构定义在头文件<code>sys/stat.h</code>中，其部分重要定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>struct stat</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">mode_t</span>		st_mode;                <span class="comment">/* [XSI] Mode of file (see below) */</span> \</span><br><span class="line"><span class="type">off_t</span>		st_size;                <span class="comment">/* [XSI] file size, in bytes */</span> \</span><br></pre></td></tr></table></figure></div>
<p>其中，<code>st_mode</code>为该文件的模式码，包含该文件的类型、权限信息等重要信息；而<code>st_stze</code>为该文件的大小，可用于判断文件大小是否超限。<br>而对<code>st_mode</code>值的定义，继续深入查看，可以在<code>sys/stat.h</code>和<code>sys/_types/_s_ifmt.h</code>文件中找到对于该值的部分定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>st_mode</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file &quot;sys/stat.h&quot; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_ISREG(m)      (((m) &amp; S_IFMT) == S_IFREG)     <span class="comment">/* regular file */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file &quot;sys/_types/_s_ifmt.h&quot; */</span></span><br><span class="line"><span class="comment">/* File type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFMT          0170000         <span class="comment">/* [XSI] type of file mask */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFREG         0100000         <span class="comment">/* [XSI] regular */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File mode */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXU         0000700         <span class="comment">/* [XSI] RWX mask for owner */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR         0000400         <span class="comment">/* [XSI] R for owner */</span></span></span><br></pre></td></tr></table></figure></div>
<p>根据定义，如果宏<code>S_ISREG(st_mode)</code>返回<code>TRUE</code>，则代表该文件为常规媒体文件，文件类型正确；<br>同时，可以仿照宏<code>S_ISREG(m)</code>，通过表达式<br><code>((st_mode) &amp; S_IRWXU) == S_IRUSR</code><br>定义宏<code>S_ISRFL(m)</code>检查文件的权限，若返回<code>TRUE</code>则代表用户有可读权限，权限类型正确。</p>
</li>
</ol>
<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>要生成针对HTTP GET请求的响应，大体可以分为一下几部分：</p>
<ol>
<li><p>从请求中获取请求文件的<code>URL</code>，并以此设置文件路径<br>若为默认<code>URL</code>，则将路径设为默认文件路径；<br>若为指定的<code>URL</code>，则根据<code>URL</code>拼接路径；<br>若<code>URL</code>长度超限，返回生成失败。</p>
</li>
<li><p>根据路径打开文件，检查文件权限、大小等信息<br>根据前面解析出的路径尝试获取该文件的<code>stat</code>信息，若获取失败则返回生成失败；<br>比对文件的<code>st_mode</code>，判断其是否为常规媒体类型文件，且用户拥有可读权限，若不符合则返回生成失败；<br>获取文件的<code>st_size</code>，计算其与<code>200 OK</code>响应的长度和是否小于缓冲区长度，若不符合则返回生成失败。</p>
</li>
<li><p>将文件内容和<code>200 OK</code>响应拷贝至缓冲区中作为响应<br>打开该文件，打开失败则返回生成失败；<br>清空缓冲区，将<code>200 OK</code>响应拷贝至缓冲区中，再将文件内容拼接至缓冲区中，生成响应。</p>
</li>
</ol>
<p>根据以上设计，可以绘制出生成HTTP GET响应的流程图。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/GET_generate.jpeg"
                      alt="GET Generate" title="GET响应生成流程"
                ><figcaption>GET Generate</figcaption></figure></p>
<h4 id="HEAD响应生成"><a href="#HEAD响应生成" class="headerlink" title="HEAD响应生成"></a>HEAD响应生成</h4><p>HTTP HEAD请求的响应生成与GET类似，只不过在最后生成响应时只需包含<code>200 OK</code>响应的内容即可。<br>因此，容易得到HTTP HEAD响应的流程图如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/HEAD_generate.jpeg"
                      alt="HEAD Generate" title="HEAD响应生成流程"
                ><figcaption>HEAD Generate</figcaption></figure></p>
<h4 id="POST响应生成"><a href="#POST响应生成" class="headerlink" title="POST响应生成"></a>POST响应生成</h4><p>HTTP POST响应的生成则更为简单，根据手册要求，只需将请求echo回客户端即可。而这一功能在Week 1中已经成功实现了，因此此处不再讨论。</p>
<h3 id="2-服务器响应模块"><a href="#2-服务器响应模块" class="headerlink" title="2. 服务器响应模块"></a>2. 服务器响应模块</h3><p>随后，还需要对Week 1中实现的服务器响应模块进行一定更改，以支持对GET、HEAD、POST请求的分别响应，以及对404、505这两种新错误的响应。<br>此次实验不需要在此模块中定义新的数据结构，因此跳过数据结构设计部分。</p>
<h5 id="协议规则设计-1"><a href="#协议规则设计-1" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>根据实验要求，响应模块总共需要支持7种不同类型的响应，分别如下：</p>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-1"></i><p>HTTP GET 请求</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-2"></i><p>HTTP HEAD 请求</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-3"></i><p>HTTP POST 请求</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-4"></i><p>400 Bad Request 错误</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-5"></i><p>501 Not Implement 错误</p>

  </div>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-square-6"></i><p>404 Not Found 错误</p>

  </div>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-square-7"></i><p>505 Version not supported 错误</p>

  </div>
<p>对于GET、HEAD、POST请求，响应的主要功能已经实现，只需按照本次实验的要求对其进行分别处理，并通过前面设计的响应生成模块生成对应的响应内容，存储至缓冲区中发送即可；<br>对于400和501错误，前面已经实现，无需更改；<br>对于505错误，要求如下：<br>请求消息解析完成后，将其HTTP版本与服务器支持HTTP版本(<code>HTTP/1.1</code>)进行比对，若版本不匹配，则响应<code>&quot;HTTP/1.1 505 HTTP Version not supported\r\n\r\n&quot;</code>。<br>对于404错误，要求如下：<br>若在GET和HEAD请求的响应生成模块中，对文件进行获取和读入时出现任何错误，导致响应生成失败，程序返回<code>HTTP_FAIL</code>，则响应<code>&quot;HTTP/1.1 404 Not Found\r\n\r\n&quot;</code>。</p>
<h3 id="3-日志记录模块"><a href="#3-日志记录模块" class="headerlink" title="3. 日志记录模块"></a>3. 日志记录模块</h3><p>最后，还需要按照给定格式记录服务器响应请求的<code>Access Log</code>，和服务器错误的<code>Error Log</code>。此外，也可以根据自己的需求记录相关日志信息，无格式要求。</p>
<h5 id="数据结构设计-1"><a href="#数据结构设计-1" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>显然，为了顺利记录日志，需要在程序中对文件进行读写操作。在C语言中使用<code>FILE</code>结构即可定义一个文件，因此无需自行定义相关数据结构。<br>随后，还需理清Apache手册中<code>Access Log</code>和<code>Error Log</code>的格式。经过阅读，并按实验的实际情况作出适当调整后，可以得到格式如下。</p>
<p><b><code>Access Log: IP:Port - frank [Time] &quot;http_method URL http_version&quot; 200 OK body_size</code></b></p>
<p><b><code>Error Log: [Time] [core:error] [client: IP:Port] error_info</code></b></p>
<p>注：IP:Port在本实验环境中统一为<code>127.0.0.1:9999</code></p>
<p>对于<code>Access Log</code>，使用之前分析或定义过的数据结构即可完成日志的生成和写入，无需进一步分析；<br>而对于<code>Error Log</code>，可以发现在其最后需要输出当前错误类型对应的错误信息<code>error_info</code>。由于错误种类较多，错误信息均为字符串，且需考虑到程序对支持其它错误的可扩展性，因此在此可以通过自定义枚举和查找表数据结构来更便捷的生成错误日志。<br>首先，需要设计一个枚举类型，用于存储每种错误类型，形如如下伪代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>ERROR TYPE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ERROR_TYPE</span> &#123;</span></span><br><span class="line">    ERROR_1,</span><br><span class="line">	ERROR_2,</span><br><span class="line">	ERROR_3,</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>随后，再定义一个字符串数组，按前面枚举类型的顺序依次存储对应的错误信息，形如如下伪代码。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>ERROR INFO TABLE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> log_error_1[] = Error_Info_1;</span><br><span class="line"><span class="type">char</span> log_error_2[] = Error_Info_2;</span><br><span class="line"><span class="type">char</span> log_error_3[] = Error_Info_3;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* error_table[] = &#123;</span><br><span class="line">	log_error_1,</span><br><span class="line">	log_error_2,</span><br><span class="line">	log_error_3,</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>如此，便得到了一个错误信息的查找表。通过<code>error_table[ERROR_TYPE]</code>就能得到对应的错误信息，以结构化生成相应的日志记录。同时，可以便捷、快速的扩展新的错误类型，只需为其添加<code>ERROR_TYPE</code>和对应的<code>log_error</code>，并插入至<code>error_table</code>的正确位置即可。</p>
<h5 id="协议规则设计-2"><a href="#协议规则设计-2" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>在完成日志记录格式和相关数据结构的定义后，很快便能完成对日志模块的设计。只需编写两个日志记录函数，用于参数化写入日志记录，并在需要记录的地方调用即可。此外，对于自定义的日志记录，直接在需要记录处对日志文件进行写入即可。</p>
<h3 id="4-缓冲区管理"><a href="#4-缓冲区管理" class="headerlink" title="4. 缓冲区管理"></a>4. 缓冲区管理</h3><h5 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h5><p>实验手册中要求对缓冲区进行合理的管理，以避免通信过程中出现缓冲区溢出错误。按照手册要求，共有3种潜在的缓冲区溢出风险。</p>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-1"></i><p>URL长度超限</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-2"></i><p>响应内容长度超限</p>

  </div>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-square-3"></i><p>请求头部长度超限</p>

  </div>
<p>对于前两种情况，在先前的设计中已经进行了相关的设计和说明，不再赘述。因此此处只对请求头部长度超限的情况进行设计。<br>根据要求，请求头部大小应不超过8192字节。</p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a>三、协议实现</h2><h3 id="1-响应生成模块-1"><a href="#1-响应生成模块-1" class="headerlink" title="1. 响应生成模块"></a>1. 响应生成模块</h3><h3 id="2-服务器响应模块-1"><a href="#2-服务器响应模块-1" class="headerlink" title="2. 服务器响应模块"></a>2. 服务器响应模块</h3><h3 id="3-日志记录模块-1"><a href="#3-日志记录模块-1" class="headerlink" title="3. 日志记录模块"></a>3. 日志记录模块</h3><p>其中，<code>Access Log</code>记录函数中应使用<code>Request</code>结构体获取请求中的<code>http_method</code>、<code>http_uri</code>、<code>http_version</code>等信息；而<code>Error Log</code>记录函数中只需传入对应的<code>ERROR_TYPE</code>，便可以完成日志记录的生成。</p>
<h3 id="4-缓冲区管理-1"><a href="#4-缓冲区管理-1" class="headerlink" title="4. 缓冲区管理"></a>4. 缓冲区管理</h3>]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>TJUOJ 4441: 合并果子（堆）</title>
    <url>/2023/09/15/tjuoj-4441-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<p>补程设课，没什么事干，就在学校OJ上找了道<a class="link"   href="http://tjuacm.chaosheng.top/problem.php?id=4441" >简单题</a>做<br>算法复健一下，顺便试一试代码块插入</p>
<p>题目给了提示，应该是道堆排序的题<br>由于每次体力增加值为当前已合并果子的总数，因此我们只需保证每次合并的两个堆都是当前果子数量最少的两个堆即可<br>思路有些像霍夫曼编码，但题目只要求求最终的体力消耗，所以没有构建霍夫曼树的必要<br>准备直接做一个最小堆，每次合并操作都取两次堆顶元素，将求出的和累加至totalCost变量中，并放回堆里<br>循环至只剩一个元素时，totalCost中值即是所求答案</p>
<p><strong>理论存在，实践开始</strong></p>
<h2 id="Input-Init"><a href="#Input-Init" class="headerlink" title="Input &amp;&amp; Init"></a>Input &amp;&amp; Init</h2><p>首先进行数据读入和建堆操作<br>使用scanf读入数据增加速度<br>然后偷个懒，用 <code>#include &lt;algorithem&gt;</code> 的make_heap函数建堆<br><strong>需要注意，题中给出的数据最大可能为n&#x3D;30000，且每项均为20000</strong><br><strong>因此结果最大可能为2e4至6e8的等差求和，即9e12左右</strong><br><strong>考虑到我们会将中间结果存在堆中，因此需要一个64位的堆和totalCost</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *heap;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">heap = <span class="keyword">new</span> <span class="type">uint64_t</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, heap + i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">make_heap</span>(heap, heap + N, greater&lt;&gt;());</span><br></pre></td></tr></table></figure></div>

<h2 id="Main-Algorithem"><a href="#Main-Algorithem" class="headerlink" title="Main Algorithem"></a>Main Algorithem</h2><p>现在编写主算法<br>每次从堆顶取两个数进行加和，随后将结果存入堆中，并累加totalCost，直至堆中只剩一个元素</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> totalCost = <span class="number">0</span>, currentCost;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mergeTimes = N - <span class="number">1</span>; mergeTimes &gt; <span class="number">0</span>; mergeTimes--) &#123;</span><br><span class="line">    currentCost = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[mergeTimes];</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line"></span><br><span class="line">    currentCost += heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = currentCost;</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line">    </span><br><span class="line">    totalCost += currentCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Quoting-Function"><a href="#Quoting-Function" class="headerlink" title="Quoting Function"></a>Quoting Function</h2><p>最后实现用于维护堆的<code>maintainHeap</code>函数<br>我们只需跟踪堆顶元素，并循环判断判断它和它最小孩子的大小关系，若大于则与之交换并继续循环，否则返回</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find the minimum element in heap[i]&#x27;s children</span></span><br><span class="line"><span class="comment">//Return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinChild</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> parentIndex, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">2</span> &lt; length)</span><br><span class="line">        <span class="keyword">return</span> heap[(parentIndex * <span class="number">2</span>) + <span class="number">1</span>] &lt; heap[(parentIndex * <span class="number">2</span>) + <span class="number">2</span>] ? (parentIndex * <span class="number">2</span>) + <span class="number">1</span> : (parentIndex * <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">1</span> &lt; length)</span><br><span class="line">        <span class="built_in">return</span> (parentIndex * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maintain the heap as a minimum heap after changing the top</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainHeap</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = <span class="number">0</span>, minChildIndex;</span><br><span class="line">    </span><br><span class="line">    minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    <span class="keyword">while</span> (heap[parentIndex] &gt; heap[minChildIndex] &amp;&amp; minChildIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = heap[parentIndex];</span><br><span class="line">        heap[parentIndex] = heap[minChildIndex];</span><br><span class="line">        heap[minChildIndex] = temp;</span><br><span class="line">        </span><br><span class="line">        parentIndex = minChildIndex;</span><br><span class="line">        minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>至此编程结束，成功AC</strong></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>algorithem</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Lab1: 产生式动物识别系统</title>
    <url>/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>产生式识别系统通过一个规则库对特征进行识别，并推断出结果。<br>系统首先输入读入一些已知特征，随后根据规则库中的规则不断尝试推断出新的特征，直至最终得到结果，或是发现无法推出结果。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/rules.jpeg"
                      alt="rules" title="规则库"
                ><figcaption>rules</figcaption></figure><br>实验要求以上图规则库为基础，编写一个产生式动物识别系统。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/simple.jpg"
                      alt="simple" title="输出样例"
                ><figcaption>simple</figcaption></figure><br>如上图所示，要求程序首先输出所有可选特征，用户输入已知特征后，程序根据规则库进行推理，输出推理过程及最后的识别结果。</p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>算法本身很简单，正好最近在学python，试着用python写一写。</p>
<h4 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h4><p>我们先把所有特征存在一个数组里，以便后面推理过程的输出。<br>同时，我们按题目要求输出所有可选特征，并要求用户按序号进行输入。<br>最后，我们还需要根据特征序号存储所有的推理规则。推理规则都是由若干个特征推出一个新特征，一个键为向量、值为变量的键值对就可以很好的存储。<br>我们设键向量中的值为推理的前提特征，而值为推理得的新特征，根据实验所给的规则库一一编写即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h4><p>推理过程也很简单，我们只要写一个大循环，不断遍历所有规则，尝试寻找所有前提特征均已知且推出特征未知的规则，并将其推出特征加入已知特征即可。<br>需要注意，由于可能存在大序号特征推出小序号特征，进而导致出现新的可使用规则的情况，因此需要用while循环不断遍历，直至推得最终动物，或是没有任何一个规则可使用，即推理失败。循环嵌套比较多，也比较复杂，我也懒得对循环做拆分了，多设几个flag即可。<br>而在推理过程中，每当使用一个能推出新特征的规则，我们就用前面的特征数组输出该规则的前提特征和推出特征，即可实现中间过程的打印。<br>最终，我们输出系统的识别结果，代码如下。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>随便测了两个，一个推出企鹅，一个推不出来。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test1.jpeg"
                      alt="test1" title="测试样例1: 企鹅"
                ><figcaption>test1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test2.jpeg"
                      alt="test2" title="测试样例2: 无动物"
                ><figcaption>test2</figcaption></figure></p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>很简单，没啥总结的。<br>python语法真怪。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>最后放一下全部代码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Lab2: 启发式搜索</title>
    <url>/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>这次实验要求我们用A算法求解八数码问题。<br>八数码问题是指，在一个3*3的棋盘上，存在8个棋子和1个空位，其中每个棋子都可以向上下左右四个方向移动（若存在空位）。给定一个初始状态和目标状态，要求找到从初始状态变换至目标状态的最短路径，输出步数和路径中的状态。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/8-puzzle.jpeg"
                      alt="8-puzzle" title="八数码问题"
                ><figcaption>8-puzzle</figcaption></figure><br>而启发式搜索算法则是一种状态空间树搜索算法。我们首先根据问题定义一个启发函数h，将h的值作为当前状态与目标状态之间的“差距”，用以判断当前状态的“好坏”。随后，我们对所有未扩展状态进行按估值h进行排序，每次都扩展当前最“好”的状态，直至找到目标状态，或是完全遍历状态空间树（无解）。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/algorithm.jpeg"
                      alt="heuristic-algorithm" title="启发式搜索"
                ><figcaption>heuristic-algorithm</figcaption></figure></p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>A算法最核心的地方就在于针对具体问题设计良好的启发函数h，剩下只需要用一个优先级队列存储所有未扩展状态，按h大小排序，挨个扩展并计算搜索深度（即步数）即可。因为这次实验要求我们给出结果路径的中间状态，所以还需要把已扩展节点也进行储存，并且在扩展过程中保留好路径信息。<br>估值函数上，这次实验给了四种h函数的备选，我们从中选择一个进行实现即可。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/h-function.jpeg"
                      alt="heuristic-function" title="启发函数"
                ><figcaption>heuristic-function</figcaption></figure><br>我选了曼哈顿距离和（启发函数二）作为启发函数，曼哈顿距离是指两个点坐标之间的绝对轴距之和，是一种很简单但很经典的启发函数。我们只需计算当前状态中每个点与目标状态中对应点的曼哈顿距离之和，便可以得到当前状态的估值h，h值越小代表状态与目标状态越接近，也就是状态越“好”。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/manhattan.jpeg"
                      alt="Manhattan-distance" title="曼哈顿距离"
                ><figcaption>Manhattan-distance</figcaption></figure><br>算法设计完成，下面就可以Coding了（这次还是用了C++）。</p>
<h4 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h4><p>首先是一些定义和初始化工作。定义状态结构体Node，存储对应的棋盘状态，估值h，步数depth。同时，因为对输出路径的要求，还需要存储状态id，以及其父状态parent，用于回溯求解路径。随后，我们需要定义用于优先级队列排序的比较函数，定义曼哈顿距离h更小的状态更优，而在h相等的情况下，我们应优先选择步数更少的状态。同时，我们定义存储未扩展节点的优先级队列open，用于回溯路径的已扩展节点序列close和路径path。最后，我们还需定义目标状态中各点的坐标。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>DEFINE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> h, depth;</span><br><span class="line">    <span class="type">int</span> id, parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.h &gt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.h &lt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.depth &gt; b.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.h最小堆</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; open;</span><br><span class="line">vector&lt;Node&gt; close;</span><br><span class="line">vector&lt;Node&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标状态</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 8 0 4</span></span><br><span class="line"><span class="comment">// 7 6 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end_loc[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="Manhattan-Distance"><a href="#Manhattan-Distance" class="headerlink" title="Manhattan Distance"></a>Manhattan Distance</h4><p>下面根据曼哈顿距离算法编写启发函数h。计算map中除0（即空位）外所有点与目标状态下的曼哈顿距离，并不断加和即可。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>ManhDis</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[i][j];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum += <span class="built_in">abs</span>(i - end_loc[num - <span class="number">1</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - end_loc[num - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Other-Functions"><a href="#Other-Functions" class="headerlink" title="Other Functions"></a>Other Functions</h4><p>随后再定义一些辅助函数。例如checkSame函数，用于检验当前状态是否在open或close序列中存在，以避免对状态的重复搜索。以及print_info函数（可选），用于在搜索过程中输出每次扩展的状态信息，辅助调试。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>HELPER</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在已搜索的相同状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSame</span><span class="params">(Node t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> same = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close[i].map[j][k] != t.map[j][k]) &#123;</span><br><span class="line">                    same = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (same)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;cur.map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id: &quot;</span>&lt;&lt;cur.id&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent: &quot;</span>&lt;&lt;cur.parent&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//depth</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;depth: &quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//h</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span>&lt;&lt;cur.h &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h4><p>下面进入main函数。首先是初始化部分，要求用户输入初始状态（以数字0表示空位），设置其相关信息，并将初始状态加入未扩展节点列表。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>INIT</span></figcaption><table><tr><td class="code"><pre><span class="line">Node start;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入初始状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        cin&gt;&gt;start.map[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start.h = <span class="built_in">H</span>(start.map);</span><br><span class="line">start.depth = <span class="number">0</span>;</span><br><span class="line">start.id = <span class="number">0</span>;</span><br><span class="line">start.parent = <span class="number">-1</span>;</span><br><span class="line">open.<span class="built_in">push</span>(start);</span><br></pre></td></tr></table></figure></div>

<h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><p>随后，开始对状态空间树的搜索。我们从open队列中取出最优的状态，检查其是否为目标状态（后续给出）后，尝试对其进行变换，搜索其子状态。对于状态的变换，虽然实际的定义是尝试让每个棋子向上下左右四个方向移动，但由于只有移动至空格位置才能变换成功，因此可以等效为尝试将空格进行上下左右四个方向（处于边界则移动失败）的移动。因此，我们可以分别尝试四种移动。对于每次变换后的子状态，我们首先更新其棋盘，并根据棋盘进行相同状态检索。若该状态已经检索过，则跳过。否则，我们应计算其估值，步数，id等信息，并记录其父状态的id，以便后续回溯求解路径。最后，我们将该状态加入未扩展状态队列open中，并继续搜索下一子状态。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>SEARCH</span></figcaption><table><tr><td class="code"><pre><span class="line">Node cur = open.<span class="built_in">top</span>();</span><br><span class="line">        open.<span class="built_in">pop</span>();</span><br><span class="line">        close.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print_info(cur);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x - <span class="number">1</span>][y];</span><br><span class="line">            next.map[x - <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历close表和open，若存在相同状态则跳过</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x + <span class="number">1</span>][y];</span><br><span class="line">            next.map[x + <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y - <span class="number">1</span>];</span><br><span class="line">            next.map[x][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y + <span class="number">1</span>];</span><br><span class="line">            next.map[x][y + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h4><p>前面提到，我们在取出一个未扩展状态后需要先检查其是否为目标状态，随后再进行扩展，现在就对检查进行讨论。当状态估值h为0时，代表状态为目标状态。因此，我们可以认定找到一个解，并输出步数和搜索空间（可指示算法运行时间）。而对于路径的回溯，我们需要从最终的状态开始，不断根据状态的parent属性，在close序列中查找id等于parent的状态，并将其加入path序列中。最后倒序输出path即为我们搜索到的求解路径。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CHECK</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.h == <span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;找到解！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;步数：&quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;搜索空间：&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;路径：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="keyword">while</span> (cur.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (close[i].id == cur.parent) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(close[i]);</span><br><span class="line">                cur = close[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第 &quot;</span> &lt;&lt;path.<span class="built_in">size</span>() - i - <span class="number">1</span> &lt;&lt;<span class="string">&quot; 步：\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout&lt;&lt;path[i].map[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span> &lt;&lt;path[i].h &lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>实验手册给出了两个测试样例，涵盖了步数较少和较多两种情况，我就直接拿来用了。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/test1.jpeg"
                      alt="test-1" title="测试样例1"
                ><figcaption>test-1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/test2.jpeg"
                      alt="test-2" title="测试样例2"
                ><figcaption>test-2</figcaption></figure><br>第二个样例的路径较长，就不全放了。</p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>这次实验的算法也比较简单，编码上搜索状态空间树的部分有点复杂，但难度也不大。而A算法最核心的就是启发函数的设计，实验直接给了4个函数备选，因此也没什么设计难度，编码实现即可。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>最后放一下全部代码。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> h, depth;</span><br><span class="line">    <span class="type">int</span> id, parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.h &gt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.h &lt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.depth &gt; b.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.h最小堆</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; open;</span><br><span class="line">vector&lt;Node&gt; close;</span><br><span class="line">vector&lt;Node&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标状态</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 8 0 4</span></span><br><span class="line"><span class="comment">// 7 6 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end_loc[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前状态的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[i][j];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum += <span class="built_in">abs</span>(i - end_loc[num - <span class="number">1</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - end_loc[num - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否存在已搜索的相同状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSame</span><span class="params">(Node t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> same = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close[i].map[j][k] != t.map[j][k]) &#123;</span><br><span class="line">                    same = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (same)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;cur.map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id: &quot;</span>&lt;&lt;cur.id&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent: &quot;</span>&lt;&lt;cur.parent&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//depth</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;depth: &quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//h</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span>&lt;&lt;cur.h &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node start;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入初始状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;start.map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start.h = <span class="built_in">H</span>(start.map);</span><br><span class="line">    start.depth = <span class="number">0</span>;</span><br><span class="line">    start.id = <span class="number">0</span>;</span><br><span class="line">    start.parent = <span class="number">-1</span>;</span><br><span class="line">    open.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!open.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node cur = open.<span class="built_in">top</span>();</span><br><span class="line">        open.<span class="built_in">pop</span>();</span><br><span class="line">        close.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print_info(cur);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.h == <span class="number">0</span>) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;找到解！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;步数：&quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;搜索空间：&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;路径：&quot;</span>&lt;&lt;endl;</span><br><span class="line">            path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">while</span> (cur.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (close[i].id == cur.parent) &#123;</span><br><span class="line">                        path.<span class="built_in">push_back</span>(close[i]);</span><br><span class="line">                        cur = close[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;第 &quot;</span> &lt;&lt;path.<span class="built_in">size</span>() - i - <span class="number">1</span> &lt;&lt;<span class="string">&quot; 步：\n&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                        cout&lt;&lt;path[i].map[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span> &lt;&lt;path[i].h &lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x - <span class="number">1</span>][y];</span><br><span class="line">            next.map[x - <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历close表和open，若存在相同状态则跳过</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x + <span class="number">1</span>][y];</span><br><span class="line">            next.map[x + <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y - <span class="number">1</span>];</span><br><span class="line">            next.map[x][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y + <span class="number">1</span>];</span><br><span class="line">            next.map[x][y + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>转智算机试直通车-1</title>
    <url>/2024/05/19/%E8%BD%AC%E6%99%BA%E7%AE%97%E6%9C%BA%E8%AF%95%E7%9B%B4%E9%80%9A%E8%BD%A6-1/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>宇宙安全声明</p>

    </div>
    <div class="notel-content">
      <p>本博客中所出现往年题目均来<a class="link"   href="https://wiki.tjubot.cn/major-changing/to-cic" >北洋维基</a>的学长分享，不一定代表真实机试题目。此外，本人并非算法竞赛选手，且不掌握任何关于转专业机试的额外信息，因此本博客的任何内容均不构成备考建议，仅为算法分享。最后，由于本人水平有限，不保证题解绝对正确，如有任何错误或问题欢迎与我联系（QQ：2827924832）。</p>

    </div>
  </div>

<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>考虑到最近几年的转智算的机试难度越来越高，且仍有继续上升的趋势，同时很多同学可能对OJ题目不太熟悉，不知道复习从何下手。因此萌生出写一篇机试往年题解的想法，为大家复习往年机试题的时候提供一点参考，也希望可以对大家的备考之路有一定的帮助。本博客预计会有5篇，覆盖21-24年四年的机试真题，并在最后给出几道对明年机试题的简单预测。不过最终更新情况还要取决于我的懒惰程度(bushi。</p>
<h2 id="关于头文件"><a href="#关于头文件" class="headerlink" title="关于头文件"></a>关于头文件</h2><p>首先，由于机试时间有限，因此推荐各位在编程时引用合适的头文件，多使用已有库辅助编程，不仅能提升编程效率，还能简化代码，减少错误，十分滴珍贵。<br>据我的经验，我们学校的OJ系统是支持万能头的，所以只需在程序开始处声明如下语句，便能解决一切头文件问题。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>万能头</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>不过，如果你因为各种原因无法使用万能头，以下是一些常用头文件的集合。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>常用头文件</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h2 id="关于复杂度"><a href="#关于复杂度" class="headerlink" title="关于复杂度"></a>关于复杂度</h2><p>复杂度的相关知识和分析技巧在数据结构课程中应该会有所提及，因此在这里就不再详细展开了。在练习过程中，有些题目可能会对程序的运行时间或运行所需内存空间有所限制（也就是常说的TLE和MLE错误），因此对于较复杂的问题，你需要具备判断自己的程序能否满足题目限制的能力（天大OJ题目的限制普遍为时间1s，内存256MB）。内存大小的判断需要根据实际使用的不同数据类型进行计算，而对于时间长短的判断，只需要在分析完复杂度后记住：<br><b>1 s &#x3D; 10^9 次运算</b></p>
<h2 id="2021年题目解析"><a href="#2021年题目解析" class="headerlink" title="2021年题目解析"></a>2021年题目解析</h2><p>近几年的机试题目难度显著的随年份上涨而增加，因此直接按年份顺序复习即可。此外，21年的题目都很简单，如果对已经有一定的上机练习经验可以跳过此博客。</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>输入一组整数，输出其中的最大值和最小值。<br>注：数据量很大。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这题简单易懂，要求一组数据中的最大值和最小值。因此，只需将所有数据读入，并不断记录已读入数据的最大值和最小值即可。但需要注意，由于需要读入的数据量可能极大，而cin&#x2F;cout的数据读写速度要显著慢于scanf&#x2F;printf，因此此题最好使用scanf来进行数据的读入。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>A</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 数据量N</span></span><br><span class="line">    <span class="type">int</span> max, min;   <span class="comment">// 用于记录已读入数据的最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 用于读入数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max);</span><br><span class="line">    min = max;  <span class="comment">// 初始化max和min为第一个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);    <span class="comment">// 读入数据</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; max)</span><br><span class="line">            max = x;    <span class="comment">// 更新当前max</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; min)</span><br><span class="line">            min = x;    <span class="comment">// 更新当前min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max: %d\nMin: %d\n&quot;</span>, max, min);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>输入两个整数，判断两数的最大公因数。<br>注：数据值很大。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这道题由于传入的数据可能很大，直接暴力搜索求解可能会时间超限，因此需要使用辗转相除法求解。这种题其实讲解的意义不大，就是考察你知不知道这种算法。但辗转相除法实在太过经典，所以还是很有必要记一下的。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>B</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);   <span class="comment">// 递归计算gcd(y, x mod y)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;   <span class="comment">// 当y为零时，x即为最小公因数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x &gt;&gt;y;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(x, y) &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>首先输入一个整数，后面跟有多行输入，每行输入一个操作符(<code>+ - *</code>)和第二个操作数。<br>对于每行输入，输出运算后结果。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这道题本身是一道很简单的模拟题，只需按题目要求对每组输入的操作符进行switch判断，然后运算即可。但在北洋维基的题目要求中并没有明确指出如何进行多行输入，因此我这里假定为不预先给出行数N，也不给出跳出条件的输入方式。<br>对于这种无法判断何时结束的多行输入，我们只需通过while循环不断检测是否有下一组数据输入即可。由于OJ的判题方式是通过文件向程序输入，再将输出与结果文件进行比对，因此在输入结束处会读入一个<code>EOF</code>标志符，代表文件结尾。而对于<code>EOF</code>输入，<code>cin</code>函数会返回0，因此类似如下的语句就能顺利对组数未知的多组输入进行正确处理。<br><code>while(cin&gt;&gt;var) {}</code><br>据此，我们就能顺利解答本题。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>C</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:           <span class="comment">// 这里直接return，所以不需要break</span></span><br><span class="line">            <span class="keyword">return</span> a + b;   <span class="comment">// 其它情况下switch语句记得写break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>, &amp;op, &amp;b)) &#123;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        a = <span class="built_in">cal</span>(a, b, op);</span><br><span class="line">        cout&lt;&lt;a &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>根据题目给出的判断条件，输入一个年份，判断其是否是闰年。</p>

    </div>
  </div>
<p>完全依赖题目给出条件的<code>if else</code>题，分享里也没有具体条件，因此不做解答。<br>猜测此题目和生环OJ上的 <a class="link"   href="https://tjucpp.top/problem.php?id=1025" >1025: 判断闰年I</a> 一样，实在想做可以去尝试一下。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>读入两个长度为10的字符串，取第一个字符串的前五个字符和第二个字符串的后五个字符，拼接为一个新串并输出。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这道题的难度依旧不大，也不需要很多算法上的技巧，逐字符操作即可，只需注意字符串最后的结束符<code>\0</code>即可。<br>不过，借助此题，推荐大家熟悉一些字符串操作的常用函数，如<code>strlen</code>、<code>strcmp</code>、<code>strcat</code>等。此外，对于字符串相关的题目，我建议大家尽量使用<code>string</code>完成，可以在很大程度上避免对结束符操作不当等产生的错误，并且相关的函数也较为简单（此题用<code>char</code>数组更方便，因此不用<code>string</code>实现）。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>E</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">11</span>], b[<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;a &gt;&gt;b &gt;&gt;b;     <span class="comment">// 丢弃b串的前五个字符，只需要后五个</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(a + <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>);    <span class="comment">// 覆盖a串后五个字符，只需要前五个</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(a, b);   <span class="comment">// 将b（b串后五个字符）拼接在a（a串前五个字符）后</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>21级题目难度很小，可能还不及C++课程的上机作业题目，比较适合先前完全没有接触过C++程序设计的同学。后续22、23年的最后两题难度应该会有所提升。</p>
<p><b>持续更新中……</b></p>
]]></content>
      <categories>
        <category>转智算机试直通车</category>
      </categories>
      <tags>
        <tag>algorithem</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="WELCOME-TO-MY-BLOG"><a href="#WELCOME-TO-MY-BLOG" class="headerlink" title="WELCOME TO MY BLOG"></a>WELCOME TO MY BLOG</h1><h3 id="BY-MENGMAO-REINE"><a href="#BY-MENGMAO-REINE" class="headerlink" title="BY MENGMAO REINE"></a>BY MENGMAO REINE</h3><h5 id="天津大学CS本科在读，随机生成一些课程实验记录、算法笔记和旅拍照片。"><a href="#天津大学CS本科在读，随机生成一些课程实验记录、算法笔记和旅拍照片。" class="headerlink" title="天津大学CS本科在读，随机生成一些课程实验记录、算法笔记和旅拍照片。"></a>天津大学CS本科在读，随机生成一些课程实验记录、算法笔记和旅拍照片。</h5><p>如果你想看一些实验记录 <a href="https://mengmaor.github.io/tags/TJU-CS-Lab/">Click here</a><br>如果你想看一些算法笔记 <a href="https://mengmaor.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Click here</a><br>如果你想转入智算 <a href="https://mengmaor.github.io/categories/%E8%BD%AC%E6%99%BA%E7%AE%97%E6%9C%BA%E8%AF%95%E7%9B%B4%E9%80%9A%E8%BD%A6/">Click here</a><br>如果你想看我的旅拍记忆 <a href="https://mengmaor.github.io/masonry/">Click here</a></p>
]]></content>
  </entry>
  <entry>
    <title>时光博物馆</title>
    <url>/masonry/index.html</url>
    <content><![CDATA[<hr>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-ticket-airline"></i><p>记忆收录</p>

    </div>
    <div class="notel-content">
      <ol>
<li>阿那亚 2022.2.22 - 2022.2.26</li>
<li>日本 2024.2.14 - 2024.2.21</li>
</ol>

    </div>
  </div>]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<p>here’s tags</p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>here’s categories</p>
]]></content>
  </entry>
</search>
