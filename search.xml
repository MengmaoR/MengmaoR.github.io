<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Image test</title>
    <url>/2023/09/14/Image-test/</url>
    <content><![CDATA[<p>Try to post a pic</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test-pic.png"
                      class="" title="test1"
                >

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test2.jpeg"
                      alt="test-pic2" title="test2"
                ><figcaption>test-pic2</figcaption></figure></p>
<p>Test end</p>
]]></content>
      <categories>
        <category>Function Test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/13/Hello/</url>
    <content><![CDATA[<p>Here’s my first BLOG<br>So let’s say</p>
<p><strong>Hello World!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>SurvivalCraft DevLog</title>
    <url>/2023/10/18/SurvivalCraft-DevLog/</url>
    <content><![CDATA[<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>暂未实现部分 </summary>
              <div class='content'>
              <div class="note danger"><p><a href="#ERROR1">1. 自定义角色第一人称视角</a></p></div><div class="note danger"><p><a href="#ERROR2">2. 仓库系统物品icon</a></p></div><div class="note danger"><p><a href="#ERROR3">3. 仓库UI的Texture</a></p></div><div class="note danger"><p><a href="#ERROR4">4. 物品栏UI的Texture</a></p></div><div class="note danger"><p><a href="#ERROR5">4. Hotbar区域UI的Texture</a></p></div>
              </div>
            </details>

<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>准备学一学UE5，顺便做一个生存+建造的游戏demo，后续做项目也方便些，所以上网找了个<a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=1&vd_source=b8a3745f5e89824ea144c46ef4066125" >教程</a>跟着做。感觉每天会写的东西也不多，就每次都在这篇更新了，如果后面内容太多可能分Part。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>最开始的配置部分就不写了，正常配置就可以。<br>不过在搭github仓库的时候出了点问题，M1 Mac版的UE5一直找不到它把仓库存在哪了，最后也没找到，就先不搭了，记得备份就行。</p>
<h3 id="初始自定义角色搭建"><a href="#初始自定义角色搭建" class="headerlink" title="初始自定义角色搭建"></a>初始自定义角色搭建</h3><p>这个部分也比较简单，就是大概讲解了一下动画混合器的使用，以及编写了一下根据人物速度绑定混合后动画的蓝图<br>一些比较基本的蓝图功能也在这里第一次真的用到了，例如branch和变量定义</p>
<p>搭建角色模型的时候又出问题了，视频里推荐下载的模型只有Win能用，而且给的动画素材下载要钱，暂时就没下。<br>在商场里稍微找了找，发现有一个还不错的资源，自带一些基本的移动动画，能满足这部分第三人称角色的要求。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/CharacterSource.jpg"
                      alt="CharacterSource" title="CharacterSource"
                ><figcaption>CharacterSource</figcaption></figure><br>但这个资源在第一人称视角下表现很古怪，研究了一阵也没找到好资源，暂时用一个很简陋的版本替代，其他的做完了有需求再回来改。<br><a id="ERROR1"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7/?p=9&vd_source=b8a3745f5e89824ea144c46ef4066125" > P9 设置我们的自定义角色 P1</a></p>
</div></a></p>
<h3 id="仓库物品信息系统搭建"><a href="#仓库物品信息系统搭建" class="headerlink" title="仓库物品信息系统搭建"></a>仓库物品信息系统搭建</h3><p>这部分主要是构建了几个数组和结构体，用于存储仓库中物品的信息。然后还初次用到了蓝图的循环等新逻辑，整体没有什么困难。<br>他对物品抽象的思路比较值得学习，抽象程度比较高，在后续组织的时候想必会有一定帮助。不过他在信息结构体里存储了部分可能用不到的信息，后面可以研究一下能否把这部分剥离出基本的信息框架，通过更细分的结构体存储。<br><strong>此外，他的存储结构比较混乱，后面可以进行一定修改</strong></p>
<p>同时，视频给出的物品icon又是只有Win能使用，需要后续解决<br><a id="ERROR2"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=15&vd_source=b8a3745f5e89824ea144c46ef4066125" > P15 创建项目信息结构和第一个项目</a></p>
</div></a></p>
<p><em><strong>END OF DAY 1</strong></em></p>
<h1 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h1><h3 id="仓库HUD界面搭建"><a href="#仓库HUD界面搭建" class="headerlink" title="仓库HUD界面搭建"></a>仓库HUD界面搭建</h3><p>首先大致介绍了UI界面的设计面板，以及如何通过蓝图和GameMode设置让一个UI界面显示在游戏画面中。</p>
<p>随后是具体的仓库HUD界面的搭建。<br>后面的构建中又使用了需要下载的Texture，需要后续补全。<br><a id="ERROR3"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=15&vd_source=b8a3745f5e89824ea144c46ef4066125" > P18 创建库存小部件</a></p>
</div></a></p>
<p>这里讲解了多个用于设置UI布局的组件,UE的UI布局可以通过多种Box组件的设置完成。同时设计了一个基本的信息展示UI界面，分别包括了仓库栏，人物信息拦和合成栏。这里的界面背景需要用到课程资源贴图，所以我暂时将背景颜色设为深灰替代。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/InventoryUISub.jpg"
                      alt="Inventory UI Sub" title="Inventory UI Sub"
                ><figcaption>Inventory UI Sub</figcaption></figure></p>
<p>随后，增加了通过键盘按键控制刚才设计的UI界面打开和关闭的功能，以及随之的鼠标显示控制。</p>
<h3 id="物品HUD搭建"><a href="#物品HUD搭建" class="headerlink" title="物品HUD搭建"></a>物品HUD搭建</h3><p>创建一个小型正方形HUD，用于展示仓库中的单个物品</p>
<p>新组件介绍</p>
<ol>
<li>overlay: 覆盖层组件，添加后允许图像、文本等图层相互叠加</li>
</ol>
<p><a id="ERROR4"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7/?p=19&spm_id_from=pageDriver&vd_source=b8a3745f5e89824ea144c46ef4066125" > P19 创建物品栏小部件</a></p>
</div></a><br>随后为其添加了背景图，依然在附件中，需要下载，继续使用深灰色背景替代。<br>同时还使用了前面下载的<a href="#ERROR2">icon</a>作为物品图标，这里使用特殊颜色进行替代。<br>再然后添加了一些文字描述，介绍了文字阴影等功能，并添加了一个进度条显示物品耐久。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/InventorySlotUI.jpg"
                      alt="InventorySlot UI" title="InventorySlot UI"
                ><figcaption>InventorySlot UI</figcaption></figure></p>
<p>需要注意，对每个组件，在组建名右侧有一个Is Variable选项，勾选它便可以将该组件作为变量在蓝图中进行访问，也就可以通过程序更改组件内容。</p>
<h3 id="HUD网格容器搭建"><a href="#HUD网格容器搭建" class="headerlink" title="HUD网格容器搭建"></a>HUD网格容器搭建</h3><p>创建用于承载每个物品HUD的网格容器，使其按合理的组织方式呈现在屏幕上</p>
<p>新组件介绍</p>
<ol>
<li>Scroll Box: 滚动框，可以滚动显示其下的组件，用于在有限空间内显示大量物品</li>
<li>Uniform Grid Panel: 统一网格面板，可以将其下每个组件按相等的大小排列</li>
</ol>
<p>随后使用蓝图编写逻辑，使游戏开始时在 ItemContainerGrid 中按每行 SlotPerRow 个创建共 TotalSlots 个物品HUD。<br>同时，ItemContainerGrid 被编写为一个通用的网格显示系统，不仅可以显示仓库物品，还可以在后续其他场景中使用，具体种类通过一个enum存储。</p>
<p>最后，将前面物品HUD中所有信息的可见性设为 hidden，便可以成功创造出一个空的仓库。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/InventoryGridUI.jpg"
                      alt="Inventory Grid UI" title="Inventory Grid UI"
                ><figcaption>Inventory Grid UI</figcaption></figure></p>
<h3 id="连接库存组件与库存HUD"><a href="#连接库存组件与库存HUD" class="headerlink" title="连接库存组件与库存HUD"></a>连接库存组件与库存HUD</h3><p>这一部分的大致内容是通过蓝图接口(Blue Print Interface)连接前面实现的多个蓝图组件，随后编写了一些接口函数，以及部分中间功能。最终完成了从用户输入到库存HUD的信息传递，实现了按下 1 键就可以在库存中添加一个物品的功能。</p>
<p>感觉他的编写逻辑很奇怪，函数层层调用，而且也没有做出相应的解释。暂时先跟着做吧，顺便思考一下要不要先学一个更加基础的教程。<br><em><strong>END OF DAY 2</strong></em></p>
<h1 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h1><h3 id="拖放功能"><a href="#拖放功能" class="headerlink" title="拖放功能"></a>拖放功能</h3><p>实现了仓库中物品的拖拽和放置。<br>有一点小问题，在实现拖拽的时候是直接复制了一个新物品跟随鼠标移动，因此旧物品仍然在原先的物品栏中，视觉上略显奇怪，后面可以适当进行修改。<br>例如，在拖拽的时候先讲原有的物品删除并临时记录，如果放置失败再添加回去。</p>
<h3 id="Hotbar"><a href="#Hotbar" class="headerlink" title="Hotbar"></a>Hotbar</h3><p>实现了屏幕中下方hotbar的现实。<br><a id="ERROR5"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=27&vd_source=b8a3745f5e89824ea144c46ef4066125" > P27 设置Hotbar小部件</a></p>
</div></a></p>
<p>UI界面存在一些需要在课程资料中下载的贴图，临时用相近的颜色代替，后续补上。</p>
<p><em><strong>找了一个入门的引擎教程，先把引擎整体学习一遍再继续跟着这个做，或许会更有收获一点</strong></em><br><em><strong>等到寒假把它做完</strong></em></p>
]]></content>
      <categories>
        <category>游戏开发日志</category>
      </categories>
      <tags>
        <tag>game Deving</tag>
      </tags>
  </entry>
  <entry>
    <title>TJUOJ 4441: 合并果子（堆）</title>
    <url>/2023/09/15/tjuoj-4441-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<p>补程设课，没什么事干，就在学校OJ上找了道<a class="link"   href="http://tjuacm.chaosheng.top/problem.php?id=4441" >简单题</a>做<br>算法复健一下，顺便试一试代码块插入</p>
<p>题目给了提示，应该是道堆排序的题<br>由于每次体力增加值为当前已合并果子的总数，因此我们只需保证每次合并的两个堆都是当前果子数量最少的两个堆即可<br>思路有些像霍夫曼编码，但题目只要求求最终的体力消耗，所以没有构建霍夫曼树的必要<br>准备直接做一个最小堆，每次合并操作都取两次堆顶元素，将求出的和累加至totalCost变量中，并放回堆里<br>循环至只剩一个元素时，totalCost中值即是所求答案</p>
<p><strong>理论存在，实践开始</strong></p>
<h2 id="Input-Init"><a href="#Input-Init" class="headerlink" title="Input &amp;&amp; Init"></a>Input &amp;&amp; Init</h2><p>首先进行数据读入和建堆操作<br>使用scanf读入数据增加速度<br>然后偷个懒，用 <code>#include &lt;algorithem&gt;</code> 的make_heap函数建堆<br><strong>需要注意，题中给出的数据最大可能为n&#x3D;30000，且每项均为20000</strong><br><strong>因此结果最大可能为2e4至6e8的等差求和，即9e12左右</strong><br><strong>考虑到我们会将中间结果存在堆中，因此需要一个64位的堆和totalCost</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *heap;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">heap = <span class="keyword">new</span> <span class="type">uint64_t</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, heap + i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">make_heap</span>(heap, heap + N, greater&lt;&gt;());</span><br></pre></td></tr></table></figure></div>

<h2 id="Main-Algorithem"><a href="#Main-Algorithem" class="headerlink" title="Main Algorithem"></a>Main Algorithem</h2><p>现在编写主算法<br>每次从堆顶取两个数进行加和，随后将结果存入堆中，并累加totalCost，直至堆中只剩一个元素</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> totalCost = <span class="number">0</span>, currentCost;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mergeTimes = N - <span class="number">1</span>; mergeTimes &gt; <span class="number">0</span>; mergeTimes--) &#123;</span><br><span class="line">    currentCost = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[mergeTimes];</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line"></span><br><span class="line">    currentCost += heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = currentCost;</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line">    </span><br><span class="line">    totalCost += currentCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Quoting-Function"><a href="#Quoting-Function" class="headerlink" title="Quoting Function"></a>Quoting Function</h2><p>最后实现用于维护堆的<code>maintainHeap</code>函数<br>我们只需跟踪堆顶元素，并循环判断判断它和它最小孩子的大小关系，若大于则与之交换并继续循环，否则返回</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find the minimum element in heap[i]&#x27;s children</span></span><br><span class="line"><span class="comment">//Return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinChild</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> parentIndex, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">2</span> &lt; length)</span><br><span class="line">        <span class="keyword">return</span> heap[(parentIndex * <span class="number">2</span>) + <span class="number">1</span>] &lt; heap[(parentIndex * <span class="number">2</span>) + <span class="number">2</span>] ? (parentIndex * <span class="number">2</span>) + <span class="number">1</span> : (parentIndex * <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">1</span> &lt; length)</span><br><span class="line">        <span class="built_in">return</span> (parentIndex * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maintain the heap as a minimum heap after changing the top</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainHeap</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = <span class="number">0</span>, minChildIndex;</span><br><span class="line">    </span><br><span class="line">    minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    <span class="keyword">while</span> (heap[parentIndex] &gt; heap[minChildIndex] &amp;&amp; minChildIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = heap[parentIndex];</span><br><span class="line">        heap[parentIndex] = heap[minChildIndex];</span><br><span class="line">        heap[minChildIndex] = temp;</span><br><span class="line">        </span><br><span class="line">        parentIndex = minChildIndex;</span><br><span class="line">        minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>至此编程结束，成功AC</strong></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>algorithem</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Lab1: 产生式动物识别系统</title>
    <url>/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="产生式动物识别系统实验报告"><a href="#产生式动物识别系统实验报告" class="headerlink" title="产生式动物识别系统实验报告"></a>产生式动物识别系统实验报告</h1><h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>产生式识别系统通过一个规则库对特征进行识别，并推断出结果。<br>系统首先输入读入一些已知特征，随后根据规则库中的规则不断尝试推断出新的特征，直至最终得到结果，或是发现无法推出结果。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/rules.jpeg"
                      alt="rules" title="规则库"
                ><figcaption>rules</figcaption></figure><br>实验要求以上图规则库为基础，编写一个产生式动物识别系统。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/simple.jpg"
                      alt="simple" title="输出样例"
                ><figcaption>simple</figcaption></figure><br>如上图所示，要求程序首先输出所有可选特征，用户输入已知特征后，程序根据规则库进行推理，输出推理过程及最后的识别结果。</p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>算法本身很简单，正好最近在学python，试着用python写一写。</p>
<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>我们先把所有特征存在一个数组里，以便后面推理过程的输出。<br>同时，我们按题目要求输出所有可选特征，并要求用户按序号进行输入。<br>最后，我们还需要根据特征序号存储所有的推理规则。推理规则都是由若干个特征推出一个新特征，一个键为向量、值为变量的键值对就可以很好的存储。<br>我们设键向量中的值为推理的前提特征，而值为推理得的新特征，根据实验所给的规则库一一编写即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>推理过程也很简单，我们只要写一个大循环，不断遍历所有规则，尝试寻找所有前提特征均已知且推出特征未知的规则，并将其推出特征加入已知特征即可。<br>需要注意，由于可能存在大序号特征推出小序号特征，进而导致出现新的可使用规则的情况，因此需要用while循环不断遍历，直至推得最终动物，或是没有任何一个规则可使用，即推理失败。循环嵌套比较多，也比较复杂，我也懒得对循环做拆分了，多设几个flag即可。<br>而在推理过程中，每当使用一个能推出新特征的规则，我们就用前面的特征数组输出该规则的前提特征和推出特征，即可实现中间过程的打印。<br>最终，我们输出系统的识别结果，代码如下。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>随便测了两个，一个推出企鹅，一个推不出来。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test1.jpeg"
                      alt="test1" title="测试样例1: 企鹅"
                ><figcaption>test1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test2.jpeg"
                      alt="test2" title="测试样例2: 无动物"
                ><figcaption>test2</figcaption></figure></p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>很简单，没啥总结的。<br>python语法真怪。</p>
]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>here’s categories</p>
]]></content>
  </entry>
  <entry>
    <title>Photos</title>
    <url>/masonry/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<p>here’s tags</p>
]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>here’s about page</p>
]]></content>
  </entry>
</search>
