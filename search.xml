<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Image test</title>
    <url>/2023/09/14/Image-test/</url>
    <content><![CDATA[<p>Try to post a pic</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test-pic.png"
                      class="" title="test1"
                >

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test2.jpeg"
                      alt="test-pic2" title="test2"
                ><figcaption>test-pic2</figcaption></figure></p>
<p>Test end</p>
]]></content>
      <categories>
        <category>Function Test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/13/Hello/</url>
    <content><![CDATA[<p>Here’s my first BLOG<br>So let’s say</p>
<p><strong>Hello World!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>SurvivalCraft DevLog</title>
    <url>/2023/10/18/SurvivalCraft-DevLog/</url>
    <content><![CDATA[<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>暂未实现部分 </summary>
              <div class='content'>
              <div class="note danger"><p><a href="#ERROR1">1. 自定义角色第一人称视角</a></p></div><div class="note danger"><p><a href="#ERROR2">2. 仓库系统物品icon</a></p></div><div class="note danger"><p><a href="#ERROR3">3. 仓库UI的Texture</a></p></div><div class="note danger"><p><a href="#ERROR4">4. 物品栏UI的Texture</a></p></div><div class="note danger"><p><a href="#ERROR5">4. Hotbar区域UI的Texture</a></p></div>
              </div>
            </details>

<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>准备学一学UE5，顺便做一个生存+建造的游戏demo，后续做项目也方便些，所以上网找了个<a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=1&vd_source=b8a3745f5e89824ea144c46ef4066125" >教程</a>跟着做。感觉每天会写的东西也不多，就每次都在这篇更新了，如果后面内容太多可能分Part。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>最开始的配置部分就不写了，正常配置就可以。<br>不过在搭github仓库的时候出了点问题，M1 Mac版的UE5一直找不到它把仓库存在哪了，最后也没找到，就先不搭了，记得备份就行。</p>
<h3 id="初始自定义角色搭建"><a href="#初始自定义角色搭建" class="headerlink" title="初始自定义角色搭建"></a>初始自定义角色搭建</h3><p>这个部分也比较简单，就是大概讲解了一下动画混合器的使用，以及编写了一下根据人物速度绑定混合后动画的蓝图<br>一些比较基本的蓝图功能也在这里第一次真的用到了，例如branch和变量定义</p>
<p>搭建角色模型的时候又出问题了，视频里推荐下载的模型只有Win能用，而且给的动画素材下载要钱，暂时就没下。<br>在商场里稍微找了找，发现有一个还不错的资源，自带一些基本的移动动画，能满足这部分第三人称角色的要求。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/CharacterSource.jpg"
                      alt="CharacterSource" title="CharacterSource"
                ><figcaption>CharacterSource</figcaption></figure><br>但这个资源在第一人称视角下表现很古怪，研究了一阵也没找到好资源，暂时用一个很简陋的版本替代，其他的做完了有需求再回来改。<br><a id="ERROR1"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7/?p=9&vd_source=b8a3745f5e89824ea144c46ef4066125" > P9 设置我们的自定义角色 P1</a></p>
</div></a></p>
<h3 id="仓库物品信息系统搭建"><a href="#仓库物品信息系统搭建" class="headerlink" title="仓库物品信息系统搭建"></a>仓库物品信息系统搭建</h3><p>这部分主要是构建了几个数组和结构体，用于存储仓库中物品的信息。然后还初次用到了蓝图的循环等新逻辑，整体没有什么困难。<br>他对物品抽象的思路比较值得学习，抽象程度比较高，在后续组织的时候想必会有一定帮助。不过他在信息结构体里存储了部分可能用不到的信息，后面可以研究一下能否把这部分剥离出基本的信息框架，通过更细分的结构体存储。<br><strong>此外，他的存储结构比较混乱，后面可以进行一定修改</strong></p>
<p>同时，视频给出的物品icon又是只有Win能使用，需要后续解决<br><a id="ERROR2"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=15&vd_source=b8a3745f5e89824ea144c46ef4066125" > P15 创建项目信息结构和第一个项目</a></p>
</div></a></p>
<p><em><strong>END OF DAY 1</strong></em></p>
<h1 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h1><h3 id="仓库HUD界面搭建"><a href="#仓库HUD界面搭建" class="headerlink" title="仓库HUD界面搭建"></a>仓库HUD界面搭建</h3><p>首先大致介绍了UI界面的设计面板，以及如何通过蓝图和GameMode设置让一个UI界面显示在游戏画面中。</p>
<p>随后是具体的仓库HUD界面的搭建。<br>后面的构建中又使用了需要下载的Texture，需要后续补全。<br><a id="ERROR3"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=15&vd_source=b8a3745f5e89824ea144c46ef4066125" > P18 创建库存小部件</a></p>
</div></a></p>
<p>这里讲解了多个用于设置UI布局的组件,UE的UI布局可以通过多种Box组件的设置完成。同时设计了一个基本的信息展示UI界面，分别包括了仓库栏，人物信息拦和合成栏。这里的界面背景需要用到课程资源贴图，所以我暂时将背景颜色设为深灰替代。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/InventoryUISub.jpg"
                      alt="Inventory UI Sub" title="Inventory UI Sub"
                ><figcaption>Inventory UI Sub</figcaption></figure></p>
<p>随后，增加了通过键盘按键控制刚才设计的UI界面打开和关闭的功能，以及随之的鼠标显示控制。</p>
<h3 id="物品HUD搭建"><a href="#物品HUD搭建" class="headerlink" title="物品HUD搭建"></a>物品HUD搭建</h3><p>创建一个小型正方形HUD，用于展示仓库中的单个物品</p>
<p>新组件介绍</p>
<ol>
<li>overlay: 覆盖层组件，添加后允许图像、文本等图层相互叠加</li>
</ol>
<p><a id="ERROR4"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7/?p=19&spm_id_from=pageDriver&vd_source=b8a3745f5e89824ea144c46ef4066125" > P19 创建物品栏小部件</a></p>
</div></a><br>随后为其添加了背景图，依然在附件中，需要下载，继续使用深灰色背景替代。<br>同时还使用了前面下载的<a href="#ERROR2">icon</a>作为物品图标，这里使用特殊颜色进行替代。<br>再然后添加了一些文字描述，介绍了文字阴影等功能，并添加了一个进度条显示物品耐久。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/InventorySlotUI.jpg"
                      alt="InventorySlot UI" title="InventorySlot UI"
                ><figcaption>InventorySlot UI</figcaption></figure></p>
<p>需要注意，对每个组件，在组建名右侧有一个Is Variable选项，勾选它便可以将该组件作为变量在蓝图中进行访问，也就可以通过程序更改组件内容。</p>
<h3 id="HUD网格容器搭建"><a href="#HUD网格容器搭建" class="headerlink" title="HUD网格容器搭建"></a>HUD网格容器搭建</h3><p>创建用于承载每个物品HUD的网格容器，使其按合理的组织方式呈现在屏幕上</p>
<p>新组件介绍</p>
<ol>
<li>Scroll Box: 滚动框，可以滚动显示其下的组件，用于在有限空间内显示大量物品</li>
<li>Uniform Grid Panel: 统一网格面板，可以将其下每个组件按相等的大小排列</li>
</ol>
<p>随后使用蓝图编写逻辑，使游戏开始时在 ItemContainerGrid 中按每行 SlotPerRow 个创建共 TotalSlots 个物品HUD。<br>同时，ItemContainerGrid 被编写为一个通用的网格显示系统，不仅可以显示仓库物品，还可以在后续其他场景中使用，具体种类通过一个enum存储。</p>
<p>最后，将前面物品HUD中所有信息的可见性设为 hidden，便可以成功创造出一个空的仓库。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/10/18/SurvivalCraft-DevLog/InventoryGridUI.jpg"
                      alt="Inventory Grid UI" title="Inventory Grid UI"
                ><figcaption>Inventory Grid UI</figcaption></figure></p>
<h3 id="连接库存组件与库存HUD"><a href="#连接库存组件与库存HUD" class="headerlink" title="连接库存组件与库存HUD"></a>连接库存组件与库存HUD</h3><p>这一部分的大致内容是通过蓝图接口(Blue Print Interface)连接前面实现的多个蓝图组件，随后编写了一些接口函数，以及部分中间功能。最终完成了从用户输入到库存HUD的信息传递，实现了按下 1 键就可以在库存中添加一个物品的功能。</p>
<p>感觉他的编写逻辑很奇怪，函数层层调用，而且也没有做出相应的解释。暂时先跟着做吧，顺便思考一下要不要先学一个更加基础的教程。<br><em><strong>END OF DAY 2</strong></em></p>
<h1 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h1><h3 id="拖放功能"><a href="#拖放功能" class="headerlink" title="拖放功能"></a>拖放功能</h3><p>实现了仓库中物品的拖拽和放置。<br>有一点小问题，在实现拖拽的时候是直接复制了一个新物品跟随鼠标移动，因此旧物品仍然在原先的物品栏中，视觉上略显奇怪，后面可以适当进行修改。<br>例如，在拖拽的时候先讲原有的物品删除并临时记录，如果放置失败再添加回去。</p>
<h3 id="Hotbar"><a href="#Hotbar" class="headerlink" title="Hotbar"></a>Hotbar</h3><p>实现了屏幕中下方hotbar的现实。<br><a id="ERROR5"><div class="note danger"><p><a class="link"   href="https://www.bilibili.com/video/BV1tg411v7L7?p=27&vd_source=b8a3745f5e89824ea144c46ef4066125" > P27 设置Hotbar小部件</a></p>
</div></a></p>
<p>UI界面存在一些需要在课程资料中下载的贴图，临时用相近的颜色代替，后续补上。</p>
<p><em><strong>找了一个入门的引擎教程，先把引擎整体学习一遍再继续跟着这个做，或许会更有收获一点</strong></em><br><em><strong>等到寒假把它做完</strong></em></p>
]]></content>
      <categories>
        <category>游戏开发日志</category>
      </categories>
      <tags>
        <tag>game Deving</tag>
      </tags>
  </entry>
  <entry>
    <title>TJUOJ 4441: 合并果子（堆）</title>
    <url>/2023/09/15/tjuoj-4441-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<p>补程设课，没什么事干，就在学校OJ上找了道<a class="link"   href="http://tjuacm.chaosheng.top/problem.php?id=4441" >简单题</a>做<br>算法复健一下，顺便试一试代码块插入</p>
<p>题目给了提示，应该是道堆排序的题<br>由于每次体力增加值为当前已合并果子的总数，因此我们只需保证每次合并的两个堆都是当前果子数量最少的两个堆即可<br>思路有些像霍夫曼编码，但题目只要求求最终的体力消耗，所以没有构建霍夫曼树的必要<br>准备直接做一个最小堆，每次合并操作都取两次堆顶元素，将求出的和累加至totalCost变量中，并放回堆里<br>循环至只剩一个元素时，totalCost中值即是所求答案</p>
<p><strong>理论存在，实践开始</strong></p>
<h2 id="Input-Init"><a href="#Input-Init" class="headerlink" title="Input &amp;&amp; Init"></a>Input &amp;&amp; Init</h2><p>首先进行数据读入和建堆操作<br>使用scanf读入数据增加速度<br>然后偷个懒，用 <code>#include &lt;algorithem&gt;</code> 的make_heap函数建堆<br><strong>需要注意，题中给出的数据最大可能为n&#x3D;30000，且每项均为20000</strong><br><strong>因此结果最大可能为2e4至6e8的等差求和，即9e12左右</strong><br><strong>考虑到我们会将中间结果存在堆中，因此需要一个64位的堆和totalCost</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *heap;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">heap = <span class="keyword">new</span> <span class="type">uint64_t</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, heap + i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">make_heap</span>(heap, heap + N, greater&lt;&gt;());</span><br></pre></td></tr></table></figure></div>

<h2 id="Main-Algorithem"><a href="#Main-Algorithem" class="headerlink" title="Main Algorithem"></a>Main Algorithem</h2><p>现在编写主算法<br>每次从堆顶取两个数进行加和，随后将结果存入堆中，并累加totalCost，直至堆中只剩一个元素</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> totalCost = <span class="number">0</span>, currentCost;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mergeTimes = N - <span class="number">1</span>; mergeTimes &gt; <span class="number">0</span>; mergeTimes--) &#123;</span><br><span class="line">    currentCost = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[mergeTimes];</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line"></span><br><span class="line">    currentCost += heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = currentCost;</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line">    </span><br><span class="line">    totalCost += currentCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Quoting-Function"><a href="#Quoting-Function" class="headerlink" title="Quoting Function"></a>Quoting Function</h2><p>最后实现用于维护堆的<code>maintainHeap</code>函数<br>我们只需跟踪堆顶元素，并循环判断判断它和它最小孩子的大小关系，若大于则与之交换并继续循环，否则返回</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find the minimum element in heap[i]&#x27;s children</span></span><br><span class="line"><span class="comment">//Return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinChild</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> parentIndex, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">2</span> &lt; length)</span><br><span class="line">        <span class="keyword">return</span> heap[(parentIndex * <span class="number">2</span>) + <span class="number">1</span>] &lt; heap[(parentIndex * <span class="number">2</span>) + <span class="number">2</span>] ? (parentIndex * <span class="number">2</span>) + <span class="number">1</span> : (parentIndex * <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">1</span> &lt; length)</span><br><span class="line">        <span class="built_in">return</span> (parentIndex * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maintain the heap as a minimum heap after changing the top</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainHeap</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = <span class="number">0</span>, minChildIndex;</span><br><span class="line">    </span><br><span class="line">    minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    <span class="keyword">while</span> (heap[parentIndex] &gt; heap[minChildIndex] &amp;&amp; minChildIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = heap[parentIndex];</span><br><span class="line">        heap[parentIndex] = heap[minChildIndex];</span><br><span class="line">        heap[minChildIndex] = temp;</span><br><span class="line">        </span><br><span class="line">        parentIndex = minChildIndex;</span><br><span class="line">        minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>至此编程结束，成功AC</strong></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>algorithem</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Lab1: 产生式动物识别系统</title>
    <url>/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="产生式动物识别系统实验报告"><a href="#产生式动物识别系统实验报告" class="headerlink" title="产生式动物识别系统实验报告"></a>产生式动物识别系统实验报告</h1><h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>产生式识别系统通过一个规则库对特征进行识别，并推断出结果。<br>系统首先输入读入一些已知特征，随后根据规则库中的规则不断尝试推断出新的特征，直至最终得到结果，或是发现无法推出结果。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/rules.jpeg"
                      alt="rules" title="规则库"
                ><figcaption>rules</figcaption></figure><br>实验要求以上图规则库为基础，编写一个产生式动物识别系统。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/simple.jpg"
                      alt="simple" title="输出样例"
                ><figcaption>simple</figcaption></figure><br>如上图所示，要求程序首先输出所有可选特征，用户输入已知特征后，程序根据规则库进行推理，输出推理过程及最后的识别结果。</p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>算法本身很简单，正好最近在学python，试着用python写一写。</p>
<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>我们先把所有特征存在一个数组里，以便后面推理过程的输出。<br>同时，我们按题目要求输出所有可选特征，并要求用户按序号进行输入。<br>最后，我们还需要根据特征序号存储所有的推理规则。推理规则都是由若干个特征推出一个新特征，一个键为向量、值为变量的键值对就可以很好的存储。<br>我们设键向量中的值为推理的前提特征，而值为推理得的新特征，根据实验所给的规则库一一编写即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>推理过程也很简单，我们只要写一个大循环，不断遍历所有规则，尝试寻找所有前提特征均已知且推出特征未知的规则，并将其推出特征加入已知特征即可。<br>需要注意，由于可能存在大序号特征推出小序号特征，进而导致出现新的可使用规则的情况，因此需要用while循环不断遍历，直至推得最终动物，或是没有任何一个规则可使用，即推理失败。循环嵌套比较多，也比较复杂，我也懒得对循环做拆分了，多设几个flag即可。<br>而在推理过程中，每当使用一个能推出新特征的规则，我们就用前面的特征数组输出该规则的前提特征和推出特征，即可实现中间过程的打印。<br>最终，我们输出系统的识别结果，代码如下。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>随便测了两个，一个推出企鹅，一个推不出来。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test1.jpeg"
                      alt="test1" title="测试样例1: 企鹅"
                ><figcaption>test1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test2.jpeg"
                      alt="test2" title="测试样例2: 无动物"
                ><figcaption>test2</figcaption></figure></p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>很简单，没啥总结的。<br>python语法真怪。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>最后放一下全部代码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
  </entry>
  <entry>
    <title>AI Lab2: 启发式搜索</title>
    <url>/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="启发式搜索实验报告"><a href="#启发式搜索实验报告" class="headerlink" title="启发式搜索实验报告"></a>启发式搜索实验报告</h1><h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>这次实验要求我们用A算法求解八数码问题。<br>八数码问题是指，在一个3*3的棋盘上，存在8个棋子和1个空位，其中每个棋子都可以向上下左右四个方向移动（若存在空位）。给定一个初始状态和目标状态，要求找到从初始状态变换至目标状态的最短路径，输出步数和路径中的状态。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/8-puzzle.jpeg"
                      alt="8-puzzle" title="八数码问题"
                ><figcaption>8-puzzle</figcaption></figure><br>而启发式搜索算法则是一种状态空间树搜索算法。我们首先根据问题定义一个启发函数h，将h的值作为当前状态与目标状态之间的“差距”，用以判断当前状态的“好坏”。随后，我们对所有未扩展状态进行按估值h进行排序，每次都扩展当前最“好”的状态，直至找到目标状态，或是完全遍历状态空间树（无解）。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/algorithm.jpeg"
                      alt="heuristic-algorithm" title="启发式搜索"
                ><figcaption>heuristic-algorithm</figcaption></figure></p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>A算法最核心的地方就在于针对具体问题设计良好的启发函数h，剩下只需要用一个优先级队列存储所有未扩展状态，按h大小排序，挨个扩展并计算搜索深度（即步数）即可。因为这次实验要求我们给出结果路径的中间状态，所以还需要把已扩展节点也进行储存，并且在扩展过程中保留好路径信息。<br>估值函数上，这次实验给了四种h函数的备选，我们从中选择一个进行实现即可。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/h-function.jpeg"
                      alt="heuristic-function" title="启发函数"
                ><figcaption>heuristic-function</figcaption></figure><br>我选了曼哈顿距离和（启发函数二）作为启发函数，曼哈顿距离是指两个点坐标之间的绝对轴距之和，是一种很简单但很经典的启发函数。我们只需计算当前状态中每个点与目标状态中对应点的曼哈顿距离之和，便可以得到当前状态的估值h，h值越小代表状态与目标状态越接近，也就是状态越“好”。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/manhattan.jpeg"
                      alt="Manhattan-distance" title="曼哈顿距离"
                ><figcaption>Manhattan-distance</figcaption></figure><br>算法设计完成，下面就可以Coding了（这次还是用了C++）。</p>
<h2 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h2><p>首先是一些定义和初始化工作。定义状态结构体Node，存储对应的棋盘状态，估值h，步数depth。同时，因为对输出路径的要求，还需要存储状态id，以及其父状态parent，用于回溯求解路径。随后，我们需要定义用于优先级队列排序的比较函数，定义曼哈顿距离h更小的状态更优，而在h相等的情况下，我们应优先选择步数更少的状态。同时，我们定义存储未扩展节点的优先级队列open，用于回溯路径的已扩展节点序列close和路径path。最后，我们还需定义目标状态中各点的坐标。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>DEFINE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> h, depth;</span><br><span class="line">    <span class="type">int</span> id, parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.h &gt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.h &lt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.depth &gt; b.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.h最小堆</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; open;</span><br><span class="line">vector&lt;Node&gt; close;</span><br><span class="line">vector&lt;Node&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标状态</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 8 0 4</span></span><br><span class="line"><span class="comment">// 7 6 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end_loc[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="Manhattan-Distance"><a href="#Manhattan-Distance" class="headerlink" title="Manhattan Distance"></a>Manhattan Distance</h2><p>下面根据曼哈顿距离算法编写启发函数h。计算map中除0（即空位）外所有点与目标状态下的曼哈顿距离，并不断加和即可。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>ManhDis</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[i][j];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum += <span class="built_in">abs</span>(i - end_loc[num - <span class="number">1</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - end_loc[num - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Other-Functions"><a href="#Other-Functions" class="headerlink" title="Other Functions"></a>Other Functions</h2><p>随后再定义一些辅助函数。例如checkSame函数，用于检验当前状态是否在open或close序列中存在，以避免对状态的重复搜索。以及print_info函数（可选），用于在搜索过程中输出每次扩展的状态信息，辅助调试。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>HELPER</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在已搜索的相同状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSame</span><span class="params">(Node t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> same = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close[i].map[j][k] != t.map[j][k]) &#123;</span><br><span class="line">                    same = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (same)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;cur.map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id: &quot;</span>&lt;&lt;cur.id&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent: &quot;</span>&lt;&lt;cur.parent&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//depth</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;depth: &quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//h</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span>&lt;&lt;cur.h &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>下面进入main函数。首先是初始化部分，要求用户输入初始状态（以数字0表示空位），设置其相关信息，并将初始状态加入未扩展节点列表。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>INIT</span></figcaption><table><tr><td class="code"><pre><span class="line">Node start;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入初始状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        cin&gt;&gt;start.map[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start.h = <span class="built_in">H</span>(start.map);</span><br><span class="line">start.depth = <span class="number">0</span>;</span><br><span class="line">start.id = <span class="number">0</span>;</span><br><span class="line">start.parent = <span class="number">-1</span>;</span><br><span class="line">open.<span class="built_in">push</span>(start);</span><br></pre></td></tr></table></figure></div>

<h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>随后，开始对状态空间树的搜索。我们从open队列中取出最优的状态，检查其是否为目标状态（后续给出）后，尝试对其进行变换，搜索其子状态。对于状态的变换，虽然实际的定义是尝试让每个棋子向上下左右四个方向移动，但由于只有移动至空格位置才能变换成功，因此可以等效为尝试将空格进行上下左右四个方向（处于边界则移动失败）的移动。因此，我们可以分别尝试四种移动。对于每次变换后的子状态，我们首先更新其棋盘，并根据棋盘进行相同状态检索。若该状态已经检索过，则跳过。否则，我们应计算其估值，步数，id等信息，并记录其父状态的id，以便后续回溯求解路径。最后，我们将该状态加入未扩展状态队列open中，并继续搜索下一子状态。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>SEARCH</span></figcaption><table><tr><td class="code"><pre><span class="line">Node cur = open.<span class="built_in">top</span>();</span><br><span class="line">        open.<span class="built_in">pop</span>();</span><br><span class="line">        close.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print_info(cur);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x - <span class="number">1</span>][y];</span><br><span class="line">            next.map[x - <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历close表和open，若存在相同状态则跳过</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x + <span class="number">1</span>][y];</span><br><span class="line">            next.map[x + <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y - <span class="number">1</span>];</span><br><span class="line">            next.map[x][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y + <span class="number">1</span>];</span><br><span class="line">            next.map[x][y + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h2><p>前面提到，我们在取出一个未扩展状态后需要先检查其是否为目标状态，随后再进行扩展，现在就对检查进行讨论。当状态估值h为0时，代表状态为目标状态。因此，我们可以认定找到一个解，并输出步数和搜索空间（可指示算法运行时间）。而对于路径的回溯，我们需要从最终的状态开始，不断根据状态的parent属性，在close序列中查找id等于parent的状态，并将其加入path序列中。最后倒序输出path即为我们搜索到的求解路径。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CHECK</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.h == <span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;找到解！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;步数：&quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;搜索空间：&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;路径：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="keyword">while</span> (cur.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (close[i].id == cur.parent) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(close[i]);</span><br><span class="line">                cur = close[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第 &quot;</span> &lt;&lt;path.<span class="built_in">size</span>() - i - <span class="number">1</span> &lt;&lt;<span class="string">&quot; 步：\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout&lt;&lt;path[i].map[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span> &lt;&lt;path[i].h &lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>实验手册给出了两个测试样例，涵盖了步数较少和较多两种情况，我就直接拿来用了。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/test1.jpeg"
                      alt="test-1" title="测试样例1"
                ><figcaption>test-1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/test2.jpeg"
                      alt="test-2" title="测试样例2"
                ><figcaption>test-2</figcaption></figure><br>第二个样例的路径较长，就不全放了。</p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>这次实验的算法也比较简单，编码上搜索状态空间树的部分有点复杂，但难度也不大。而A算法最核心的就是启发函数的设计，实验直接给了4个函数备选，因此也没什么设计难度，编码实现即可。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>最后放一下全部代码。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> h, depth;</span><br><span class="line">    <span class="type">int</span> id, parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.h &gt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.h &lt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.depth &gt; b.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.h最小堆</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; open;</span><br><span class="line">vector&lt;Node&gt; close;</span><br><span class="line">vector&lt;Node&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标状态</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 8 0 4</span></span><br><span class="line"><span class="comment">// 7 6 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end_loc[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前状态的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[i][j];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum += <span class="built_in">abs</span>(i - end_loc[num - <span class="number">1</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - end_loc[num - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否存在已搜索的相同状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSame</span><span class="params">(Node t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> same = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close[i].map[j][k] != t.map[j][k]) &#123;</span><br><span class="line">                    same = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (same)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;cur.map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id: &quot;</span>&lt;&lt;cur.id&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent: &quot;</span>&lt;&lt;cur.parent&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//depth</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;depth: &quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//h</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span>&lt;&lt;cur.h &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node start;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入初始状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;start.map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start.h = <span class="built_in">H</span>(start.map);</span><br><span class="line">    start.depth = <span class="number">0</span>;</span><br><span class="line">    start.id = <span class="number">0</span>;</span><br><span class="line">    start.parent = <span class="number">-1</span>;</span><br><span class="line">    open.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!open.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node cur = open.<span class="built_in">top</span>();</span><br><span class="line">        open.<span class="built_in">pop</span>();</span><br><span class="line">        close.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print_info(cur);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.h == <span class="number">0</span>) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;找到解！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;步数：&quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;搜索空间：&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;路径：&quot;</span>&lt;&lt;endl;</span><br><span class="line">            path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">while</span> (cur.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (close[i].id == cur.parent) &#123;</span><br><span class="line">                        path.<span class="built_in">push_back</span>(close[i]);</span><br><span class="line">                        cur = close[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;第 &quot;</span> &lt;&lt;path.<span class="built_in">size</span>() - i - <span class="number">1</span> &lt;&lt;<span class="string">&quot; 步：\n&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                        cout&lt;&lt;path[i].map[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span> &lt;&lt;path[i].h &lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x - <span class="number">1</span>][y];</span><br><span class="line">            next.map[x - <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历close表和open，若存在相同状态则跳过</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x + <span class="number">1</span>][y];</span><br><span class="line">            next.map[x + <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y - <span class="number">1</span>];</span><br><span class="line">            next.map[x][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y + <span class="number">1</span>];</span><br><span class="line">            next.map[x][y + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>here’s categories</p>
]]></content>
  </entry>
  <entry>
    <title>Photos</title>
    <url>/masonry/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<p>here’s tags</p>
]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>here’s about page</p>
]]></content>
  </entry>
</search>
