<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/13/Hello/</url>
    <content><![CDATA[<p>Here’s my first BLOG<br>So let’s say</p>
<p><strong>Hello World!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Lenet-5 识别手写数字</title>
    <url>/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>本次实验，我们需要实现一个基于Lenet-5神经网络模型的手写数字识别系统。同时，使用MNIST数据集进行训练和测试。</p>
<h3 id="Lenet-5"><a href="#Lenet-5" class="headerlink" title="Lenet-5"></a>Lenet-5</h3><p>首先简要介绍一下Lenet-5模型。<br>LeNet-5模型是一个十分经典的卷积神经网络模型，最早由Yann LeCun教授于1998年在其论文《Gradient-Based Learning Applied to Document Recognition》中提出。作为首个成功应用于数字识别任务的卷积神经网络，LeNet-5在MNIST数据集上的准确率约为99.2%。该模型的提出标志着卷积神经网络在计算机视觉领域的应用取得了重要进展。</p>
<h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p>Lenet-5模型共有7层（不计输入层），每层均包含可训练参数。模型架构如下图所示。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/lenet-5.jpeg"
                      alt="Lenet-5 Model" title="Lenet-5模型架构"
                ><figcaption>Lenet-5 Model</figcaption></figure><br>下面对架构进行逐层讲解。</p>
<h4 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h4><p>输入层所输入的图片大小应为32*32，略大于MNIST数据集中图片大小（28*28），因此需要为输入图像加上宽度为2的padding。这么做是因为我们希望在第一层卷积层（卷积核5*5）进行卷积时，将原输入图片中的所有数据保持在特征检测子感受野（receptive field）的中心。</p>
<h4 id="C1层"><a href="#C1层" class="headerlink" title="C1层"></a>C1层</h4><p>C1层为卷积层，使用6个5*5的卷积核进行卷积，步长为1，得到6个28*28的特征图。</p>
<h4 id="S2层"><a href="#S2层" class="headerlink" title="S2层"></a>S2层</h4><p>S2层为池化层，采用最大池化，池化大小为2*2，得到6个14*14的特征图。<br>在原论文中，Lecun教授采用的是平均池化的方法进行池化，但在后人进一步探索的过程中，发现采用最大池化效果更佳，因此目前的Lenet-5模型的池化层都普遍采用最大池化。</p>
<h4 id="C3层"><a href="#C3层" class="headerlink" title="C3层"></a>C3层</h4><p>C3层为卷积层，使用16个5*5的卷积核进行卷积，步长为1，得到16个10*10的特征图。</p>
<h4 id="S4层"><a href="#S4层" class="headerlink" title="S4层"></a>S4层</h4><p>S4层为池化层，采用最大池化，池化大小为2*2，得到16个5*5的特征图。</p>
<h4 id="C5层"><a href="#C5层" class="headerlink" title="C5层"></a>C5层</h4><p>C5层较为特殊。在设计中，C5层为一个卷积层，使用120个5*5，步长为1的卷积核进行卷积。因此，这一层最终会得到120个大小为1*1的特征图，这其实就相当于一个全连接层。但在实现时，最好依旧将其设为卷积层而非全连接层，以保证对于其它大小的输入数据（如64*64的图像输入），模型具有相同的结构。</p>
<h4 id="F6层"><a href="#F6层" class="headerlink" title="F6层"></a>F6层</h4><p>F6层为全连接层，输出大小为84。</p>
<h4 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h4><p>输出层与F6层全连接，输出长度为10的张量，指示最终的预测结果。</p>
<p>下面是模型各层参数的汇总表格<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/parameter.jpeg"
                      alt="Parameter" title="模型参数表"
                ><figcaption>Parameter</figcaption></figure></p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>对于这次实验，不需要做过多算法设计上的工作，只需成功将模型复现，并使用MNIST数据集进行训练和测试即可。<br>这次使用pytorch进行实现，代码主要分为5个模块，分别为</p>
<ol>
<li>数据加载模块</li>
<li>模型定义模块</li>
<li>训练模块</li>
<li>测试模块</li>
<li>展示demo<br>下面进行详细阐述。</li>
</ol>
<h3 id="数据加载模块"><a href="#数据加载模块" class="headerlink" title="数据加载模块"></a>数据加载模块</h3><p>由于pytorch中已经定义了MNIST数据集的相关处理函数，因此只需直接将其导入即可，只需配置几个参数便能完成数据集的导入。<br>在MNIST数据集中存在训练用数据和测试用数据两个测试文件，我们在导入时将train设为True即可使用训练集，而设为False即可使用测试集。同时，如果指定下没有MNIST数据集，通过将download设为True可以直接进行下载。<br>随后，还需要创建对训练数据和测试数据的数据加载器，用于批量加载多组数据。对于训练数据，每次加载的数据量需要谨慎选择，因为其会影响模型最终的学习效果，在这里我们选择较为常用且大小合适的数据量128。而对于测试集，则不会对最终的测试结果产生影响，考虑到测试集数据总量为10k，在这里我们就选择100作为数据加载量。<br>同时，对于训练数据，我们应该在每加载一轮后对数据进行洗牌，使数据随机重新排列，以避免数据的顺序对模型的学习产生影响，通过将shuffle设为True即可完成这一操作。测试数据则不需要洗牌。</p>
<h3 id="模型定义模块"><a href="#模型定义模块" class="headerlink" title="模型定义模块"></a>模型定义模块</h3><p>对于模型定义部分，只需按照前面给出的模型架构逐层进行定义即可。需要注意的是，在前向传播函数中，C5层的每个卷积核计算完毕后得到的数据是一个1*1的二维向量，还需要将其展平为一维后才能输入F6全连接层进行计算。<br>此外，还应定义并对每层的输出使用激活函数，已获得更好的训练效果。在这里使用的激活函数十分简单但也十分经典，如果输入x大于0就输出x，否则输出0，用于丢弃所有前向传播过程中的负值。<br>具体代码如下。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>Lenet-5 Model</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># LeNet-5模型架构定义</span></span><br><span class="line"><span class="comment"># LeNet-5模型架构定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet5</span>(tnn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LeNet5, self).__init__()  <span class="comment"># 父类构造函数</span></span><br><span class="line">        self.relu = tnn.ReLU()   <span class="comment"># 激活函数</span></span><br><span class="line">        self.conv1 = tnn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)  <span class="comment"># 第一层卷积层，输入通道数为1，输出通道数为6，卷积核大小为5，padding为2</span></span><br><span class="line">        self.pool2 = tnn.MaxPool2d(<span class="number">2</span>)  <span class="comment"># 第二层池化层，池化核大小为2（最大池化）</span></span><br><span class="line">        self.conv3 = tnn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># 第三层卷积层，输入通道数为6，输出通道数为16，卷积核大小为5</span></span><br><span class="line">        self.pool4 = tnn.MaxPool2d(<span class="number">2</span>)  <span class="comment"># 第四层池化层，池化核大小为2（最大池化）</span></span><br><span class="line">        self.conv5 = tnn.Conv2d(<span class="number">16</span>, <span class="number">120</span>, kernel_size=<span class="number">5</span>)  <span class="comment"># 第五层卷积层，输入通道数为16，输出通道数为120，卷积核大小为5</span></span><br><span class="line">        self.fc6 = tnn.Linear(<span class="number">120</span>, <span class="number">84</span>)  <span class="comment"># 第六层全连接层，输入大小为120，输出大小为84</span></span><br><span class="line">        self.fc7 = tnn.Linear(<span class="number">84</span>, <span class="number">10</span>)  <span class="comment"># 第七层全连接层，输入大小为84，输出大小为10</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, other</span>):</span><br><span class="line">        in_size = other.size(<span class="number">0</span>)</span><br><span class="line">        out = self.relu(self.pool2(self.conv1(other)))  <span class="comment"># C1卷积层后接S2池化层和激活函数</span></span><br><span class="line">        out = self.relu(self.pool4(self.conv3(out)))  <span class="comment"># C3卷积层后接S4池化层和激活函数</span></span><br><span class="line">        out = self.relu(self.conv5(out))  <span class="comment"># F5卷积层后接激活函数</span></span><br><span class="line">        out = out.view(in_size, -<span class="number">1</span>)  <span class="comment"># 将输出展平</span></span><br><span class="line">        out = self.relu(self.fc6(out))  <span class="comment"># F6全连接层后接激活函数</span></span><br><span class="line">        out = self.fc7(out)  <span class="comment"># 输出层为全连接层</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"> </span><br><span class="line">model = LeNet5()  <span class="comment"># 创建LeNet-5模型</span></span><br></pre></td></tr></table></figure></div>

<h3 id="训练模块"><a href="#训练模块" class="headerlink" title="训练模块"></a>训练模块</h3><p>对于训练模块，我们首先需要定义损失计算函数和优化器。损失计算函数此处使用比较经典的交叉熵损失函数，而优化器也使用经典的Adam优化器，初始学习率设为0.001。<br>随后，将模型设置为训练模式，便可以开始使用训练数据集进行训练，训练按如下流程进行。</p>
<ol>
<li>加载训练数据，并将数据输入模型中进行运算</li>
<li>得到模型运算结果，将结果和数据标签传入损失函数，计算损失</li>
<li>根据损失对模型进行反向传播，计算各连接的梯度</li>
<li>通过优化器和前面计算得到的梯度对模型进行参数更新</li>
<li>实时输出训练进度和损失值<br>在训练中，需要注意每训练完一组数据后需要对模型进行梯度清零，以避免前面的数据影响后续数据的训练效果，进而导致过拟合等问题。此外，在多次迭代训练的情况下，我采用了学习率梯度下降的训练方式，每十次迭代下降1&#x2F;10，以提高高次迭代下的训练效果。<br>对于实时进度输出，可以通过在每行输出后添加<code>end=&#39;\r&#39;</code>的方式清除上一条输出，以实现输出实时变化的效果，并可以据此制作实时进度条，十分有趣。<br>最后，我们需要将训练完毕的模型进行保存，以便后续测试和演示使用。<br>此模块部分代码如下。<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>Training Module</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模块 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):</span><br><span class="line">    model.train()  <span class="comment"># 设置模型为训练模式</span></span><br><span class="line">    process = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:     <span class="comment"># 每10个训练周期，学习率梯度下降至原来的0.1</span></span><br><span class="line">        <span class="keyword">for</span> param_group <span class="keyword">in</span> opt.param_groups:</span><br><span class="line">            param_group[<span class="string">&#x27;lr&#x27;</span>] *= <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">for</span> batch_index, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, target = Variable(data), Variable(target)</span><br><span class="line">        opt.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        output = model(data)  <span class="comment"># 前向传播</span></span><br><span class="line">        loss = loss_counter(output, target)  <span class="comment"># 计算损失</span></span><br><span class="line">        loss.backward()  <span class="comment"># 反向传播，计算梯度</span></span><br><span class="line">        opt.step()  <span class="comment"># 更新模型参数</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>对于测试模块，与前面的训练模块类似，首先将模型设为训练模式，随后读入数据并传入模型进行计算，再根据计算结果与标签进行对比，获得损失。但并不执行反向传播和参数更新这两项操作，而是将通过将计算结果转化为预测结果，再将标签进行对比来判断模型预测结果的正误。统计每组测试数据的预测正确性和所有数据的平均损失，也将其实时输出，以查看模型的正确率。<br>在预测结果的判断上，我们只需先取得模型的输出（10维张量），从中寻找值最大的一个分量，该分量的下标即是模型所预测的数字。<br>下面是此部分代码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>Testing Module</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试模块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">epoch</span>):</span><br><span class="line">    <span class="comment"># 读取模型</span></span><br><span class="line">    model = torch.load(<span class="string">&#x27;model_&#123;&#125;.pkl&#x27;</span>.<span class="built_in">format</span>(epoch))</span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># 设置模型为评估模式</span></span><br><span class="line">    ave_loss = <span class="number">0</span></span><br><span class="line">    accury = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, target = Variable(data), Variable(target)</span><br><span class="line">            output = model(data)  <span class="comment"># 前向传播</span></span><br><span class="line">            ave_loss += loss_counter(output, target).item() / <span class="built_in">len</span>(test_loader.dataset)  <span class="comment"># 计算平均损失</span></span><br><span class="line">            pred = torch.<span class="built_in">max</span>(output.data, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 模型预测结果</span></span><br><span class="line">            accury += pred.eq(target.data.view_as(pred)).cpu().<span class="built_in">sum</span>()  <span class="comment"># 计算正确预测的数量</span></span><br></pre></td></tr></table></figure></div>

<h3 id="演示demo"><a href="#演示demo" class="headerlink" title="演示demo"></a>演示demo</h3><p>此模块主要实现实时测试的功能，即不使用MNIST数据集，通过手动写入数据，运行模型并输出预测结果，以起到演示模型效果的作用。<br>出于简单考虑，这里不手动输入28*28的矩阵，而是输入一个7*7的矩阵，再将其等比扩展4倍，即可得到28*28的矩阵。<br>随后，只需将矩阵输入至模型，计算结果并得到模型的预测结果，再将其输出即可。同时，输出还包括最初输入矩阵的更清晰表示，以便使用者更好的查看，以及模型输出的十维张量，以对模型计算结果有更清晰的了解（为了输出美观考虑，此处作为整数输出，实际结果应为浮点数）。<br>但需要注意，这种测试方法十分简陋，因此测试时尽量输入特征明显的数字作为输入，且演示结果并不能很好的反应模型实际性能，只能作为一种简单有趣的演示。<br>此模块部分代码如下。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>Demonstration</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    model = torch.load(<span class="string">&#x27;model_25.pkl&#x27;</span>)</span><br><span class="line">    data = demo_data</span><br><span class="line">    data = Variable(data)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> demo_input:</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> row:</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;* &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    output = model(data)</span><br><span class="line">    res = torch.<span class="built_in">max</span>(output.data, <span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Answer: \t&quot;</span>, res.item())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Output(int): \t&quot;</span>, output.data.numpy().astype(<span class="built_in">int</span>))</span><br></pre></td></tr></table></figure></div>

<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>我分别训练了迭代次数为1、5、10、15、20、25、30、40、50的模型，并对其进行了测试，得到了迭代次数与测试正确率关系如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Model Performence</span></figcaption><table><tr><td class="code"><pre><span class="line"> 1: 96.69%</span><br><span class="line"> 5: 98.74%</span><br><span class="line">10: 98.69%</span><br><span class="line">15: 98.76%</span><br><span class="line">20; 99.21%</span><br><span class="line">25: 99.26%</span><br><span class="line">30: 99.14%</span><br><span class="line">40: 99.14%</span><br><span class="line">50: 99.14%</span><br></pre></td></tr></table></figure></div>
<p>可以看到，25次迭代下的模型效果最佳，正确率可以达到99.2%以上，与最初的预期相符。此外，迭代次数大于20后模型的整体表现均不错，且在更高迭代次数下正确率保持稳定，没有出现数据过拟合而导致效果下降的问题。<br>最后，我还用演示模块进行了几次测试，结果如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/1.jpeg"
                      alt="Test 1" title="测试数字 1"
                ><figcaption>Test 1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/2.jpeg"
                      alt="Test 2" title="测试数字 2"
                ><figcaption>Test 2</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/3.jpeg"
                      alt="Test 3" title="测试数字 3"
                ><figcaption>Test 3</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/8.jpeg"
                      alt="Test 8" title="测试数字 9"
                ><figcaption>Test 8</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/26/Lenet-5-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/9.jpeg"
                      alt="Test 9" title="测试数字 9"
                ><figcaption>Test 9</figcaption></figure></p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>这次实验还比较有趣，了解并复现了一个经典的卷积神经网络，并且通过实验的机会初步认识学习了pytorch。由于实验要求中并没有给出很多模型的复现细节，例如激活函数、损失函数、优化器、学习率设置等，因此在实验过程中需要自己不断的探索，分析和调参，以得到一个不错的模型效果，过程虽然有些煎熬和枯燥，但最终得到不错的结果时还是很开心的。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>这次实验稍显复杂，就不给源码了</p>
]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程日志 Week1</title>
    <url>/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/</url>
    <content><![CDATA[<p>这次实验要求所有源码不得外传和共享，因此在博客里就不再给出源码了。</p>
<h2 id="一、实验概要"><a href="#一、实验概要" class="headerlink" title="一、实验概要"></a>一、实验概要</h2><p>第一周需要实现一个简单的echo web server模块，可以对传入的消息进行解析，判断其合法性，并按消息的不同类别进行响应。<br>对于具体的消息解析部分，利用Lex&amp;Yacc分词方法进行词法分析，以此解析出HTTP请求的种类。</p>
<h2 id="二、协议设计"><a href="#二、协议设计" class="headerlink" title="二、协议设计"></a>二、协议设计</h2><p>这次实验所要实现的功能比较简单，不需要额外设计数据结构来辅助实现。因此在数据结构部分主要描述在设计中使用到的数据结构以及对某些重要数据结构的分析。</p>
<h3 id="1-协议头结构"><a href="#1-协议头结构" class="headerlink" title="1. 协议头结构"></a>1. 协议头结构</h3><h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>在最初环境部署的阶段中，曾使用过<code>example</code>程序测试过对<code>/samples/sample_request_example</code>文件中HTTP请求的响应。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>sample_request_example</span></figcaption><table><tr><td class="code"><pre><span class="line">GET /~prs/15-441-F15/ HTTP/1.1</span><br><span class="line">Host: www.cs.cmu.edu</span><br></pre></td></tr></table></figure></div>
<p>可以看到，该文件的输入只包含了一行HTTP请求行和一行HTTP请求头部。在此情况下，框架代码能够正确识别并处理这一HTTP请求。但在实际情况中，HTTP请求包含多行请求头部，因此需要在后续的词法分析设计中保证程序可以处理多行请求头部的语法规则匹配。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/HTTPRequest.jpeg"
                      alt="HTTP Request" title="HTTP 请求报文结构"
                ><figcaption>HTTP Request</figcaption></figure><br>而对于Yacc解析出的数据，它通过一个特殊的数据结构Request来存储，该结构定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>Request</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/parse.h</span></span><br><span class="line"><span class="comment">// HTTP Request Header</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> http_version[<span class="number">50</span>];</span><br><span class="line">	<span class="type">char</span> http_method[<span class="number">50</span>];</span><br><span class="line">	<span class="type">char</span> http_uri[<span class="number">4096</span>];</span><br><span class="line">	Request_header *headers;</span><br><span class="line">	<span class="type">int</span> header_count;</span><br><span class="line">&#125; Request;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，<code>http_version</code>、<code>http_method</code>和<code>http_uri</code>将会分别存储HTTP请求行中的协议版本，请求方法和请求URI。而HTTP请求头部则被存储在一个<code>Request_header</code>结构的数组中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>Request_header</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/parse.h</span></span><br><span class="line"><span class="comment">// Header field</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> header_name[<span class="number">4096</span>];</span><br><span class="line">	<span class="type">char</span> header_value[<span class="number">4096</span>];</span><br><span class="line">&#125; Request_header;</span><br></pre></td></tr></table></figure></div>
<p>在<code>Request_header</code>中则会存储HTTP请求头部的头部字段名和值。<br>根据以上数据结构，可以在后续实验中更好的对解析后结果进行分类匹配并响应。</p>
<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>对于解析后的HTTP请求消息，共分为三种情况处理：</p>

  <div class="note-large green">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>GET&#x2F;HEAD&#x2F;POST</p>

    </div>
    <div class="notel-content">
      <p>当解析后发现消息为合法HTTP请求，且方法为GET&#x2F;HEAD&#x2F;POST，为已实现的方法，此时将消息进行重新封装，并直接发送回客户端。</p>

    </div>
  </div>

  <div class="note-large orange">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>Not-Implemented</p>

    </div>
    <div class="notel-content">
      <p>当解析后发现消息为合法的HTTP请求，但该消息请求的方法并未实现时，向客户端发送<code>&quot;HTTP/1.1 501 Not Implemented\r\n\r\n&quot;</code>。</p>

    </div>
  </div>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>Bad-Request</p>

    </div>
    <div class="notel-content">
      <p>当解析过程中发现消息格式错误，为非法消息时，向客户端发送<code>&quot;HTTP/1.1 400 Bad request\r\n\r\n&quot;</code>。</p>

    </div>
  </div>
<p>在词法分析模块将输入消息进行解析后，将缓冲区中的解析结果与上述情况进行一一匹配，便能得到正确的响应。随后再根据上述要求进行响应即可。</p>
<h3 id="2-Lex-Yacc词法分析结构"><a href="#2-Lex-Yacc词法分析结构" class="headerlink" title="2. Lex&amp;Yacc词法分析结构"></a>2. Lex&amp;Yacc词法分析结构</h3><h5 id="数据结构设计-1"><a href="#数据结构设计-1" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>总体来说，Lex&amp;Yacc词法分析的框架是：Lex先扫描每个输入的字符串，按预先设定的种类对字符串进行匹配，并将其替换为该种类的标签符。<br>随后，Yacc扫描Lex处理后得到的标签串，根据实现定义的语法规则对标签串进行规约匹配，得到规约后的输出结果。</p>
<h5 id="协议规则设计-1"><a href="#协议规则设计-1" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>在查看Yacc规约规则的源码<code>/src/parser.y</code>后，发现其中已经定义了用于识别HTTP请求行的规则<code>request_line</code>，和用于识别HTTP请求头部的规则<code>request_header</code>。仔细阅读后，发现已有的语法规则只能成功识别一行HTTP请求头部，这与实验要求不符，因此需要设计可识别多行请求头部的语法规则。<br>由于对于每行请求头部，它所遵循的语法规则都是相同的，且与单行请求头部的规则一致，因此使用递归的方式就能很好的完成多行识别，这在某些已有规则的定义中也有所体现。<br>由此，只需先对第一行按单行请求头部的语法规则进行匹配，再递归的对后续输入尝试用此规则进行匹配即可。</p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a>三、协议实现</h2><h3 id="1-客户端输入模块"><a href="#1-客户端输入模块" class="headerlink" title="1. 客户端输入模块"></a>1. 客户端输入模块</h3><p>首先，在最初的环境配置阶段，以及阅读源码后可知，<code>echo_client</code>程序目前通过命令行输入的方式来读取输入，而<code>example</code>程序则可以通过文件来获取输入。因此，首先需要将<code>echo_client</code>更改为通过文件输入。这一部分的实现较为简单，只需参照<code>/src/example.c</code>中的代码实现即可，并注意在读取参数表时加入一项输入文件的路径。</p>
<h3 id="2-词法分析模块"><a href="#2-词法分析模块" class="headerlink" title="2. 词法分析模块"></a>2. 词法分析模块</h3><p>在前面的设计部分提到过，通过递归的方式设计语法规则就可以很好的完成对多行请求头部的匹配。具体而言，在Yacc中，通过逻辑连接词<code>｜</code>就可以实现递归匹配。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>Rules_Rec</span></figcaption><table><tr><td class="code"><pre><span class="line">rules_rec: rules &#123;</span><br><span class="line">    body1;</span><br><span class="line">&#125;; |</span><br><span class="line">rules_rec &#123;</span><br><span class="line">    body2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>如上伪代码给出了一种递归语法规则<code>rules_rec</code>的定义方式。其中，<code>rules</code>是对单行定义的语法规则，而在<code>rules_rec</code>匹配时，会尝试匹配一个<code>rules</code>或是一个<code>rules_rec</code>，这就形成了递归调用，以此可以根据一个语法规则对多行中的每行都按<code>rules</code>规则进行匹配。<br>由于在框架代码中，对于单行HTTP请求头部的语法规则<code>request_header</code>已经定义，因此只需在<code>/src/parser.y</code>参照上面给出的定义方式，定义递归匹配多行的语法规则<code>request_header_rec</code>，并使用此规则进行匹配即可。<br>此外，前面提到过，<code>/src/parser.c</code>会将解析完毕的HTTP请求存储在<code>Request -&gt; headers</code>中，而在框架代码中，由于只进行一行的请求头部解析，所以程序只为<code>Request -&gt; headers</code>申请了一个元素的空间。因此还需增加程序为<code>Request -&gt; headers</code>申请的空间大小，以存储全部的HTTP请求头部信息。在这次实验中，暂且将空间大小设为64行，应该可以顺利实现实验所要求的功能。</p>
<h3 id="3-服务器响应模块"><a href="#3-服务器响应模块" class="headerlink" title="3. 服务器响应模块"></a>3. 服务器响应模块</h3><p>服务器响应模块应在<code>/src/echo_server.c</code>中实现。在服务器响应部分中，已有的框架代码会从客户端接收请求消息，将其存储至缓冲区<code>buf</code>中，并直接发送回客户端。因此，需要为其加入词法分析和对应响应功能。首先，利用在<code>/src/parser.h</code>中定义的<code>parser</code>函数，将<code>buf</code>中的内容使用词法分析模块进行解析，并将解析结果存储在专门的数据结构<code>Request</code>中。随后，可以对解析结果进行判断。在解析失败时，<code>request</code>应为空，此时返回400报错；否则解析成功，此时判断<code>request -&gt; http_method</code>是否为<code>&quot;GET&quot;\&quot;HEAD&quot;\&quot;POST&quot;</code>，若字符串比对成功，则应将解析后的消息复制至缓冲区中，并直接发送回客户端；否则，则代表请求为未实现的HTTP方法，此时返回501报错。此外，在对解析后消息进行匹配和响应时，会涉及到对缓冲区的匹配识别和修改问题。因此可以提前定义一些用于匹配和填充的字符串，用以更便捷和安全的操作缓冲区。同时，在每次发送响应时还应检查发送是否成功，此部分代码在框架代码中已经给出。由此可以写出响应模块的伪代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Response</span></figcaption><table><tr><td class="code"><pre><span class="line">IF request IS NULL</span><br><span class="line">    THEN SEND ERROR 400</span><br><span class="line">        CHECK SEND</span><br><span class="line">ELSE IF request -&gt; http_method IS &quot;GET&quot;</span><br><span class="line">        OR IS &quot;HEAD&quot; OR IS &quot;POST&quot;</span><br><span class="line">    THEN COPY request TO buf </span><br><span class="line">        SEND buf</span><br><span class="line">        CHECK SEND</span><br><span class="line">ELSE</span><br><span class="line">    THEN SEND ERROR 501</span><br><span class="line">        CHECK SEND</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure></div>
<h3 id="4-缓冲区清除"><a href="#4-缓冲区清除" class="headerlink" title="4. 缓冲区清除"></a>4. 缓冲区清除</h3><p>在每完成一个HTTP请求信息的解析和响应后，为避免上一次的消息影响对下一次消息的解析和响应结果，因此需要对解析结果<code>request</code>和缓冲区都进行清空。这一部分很容易就可以在<code>/src/echo_server.c</code>进行实现。但在一次测试中，发现如果先传输一个格式错误，响应ERROR 400的HTTP请求，再传输格式正确的HTTP请求，程序依然会判断该消息格式错误，响应ERROR 400。经过检查，发现此时<code>request</code>为空，即错误出现在词法分析模块。仔细检查测试中的输出可以发现，在输入格式正确的HTTP请求后词法分析模块进行匹配的字符串并非新输入的字符串，而是前面格式错误输入文件的后续部分。因此可以断定出现此问题的原因是词法分析模块存在未被清空的缓冲区。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/Debug.jpeg"
                      alt="Wrong Output Log" title="错误部分的详细输出"
                ><figcaption>Wrong Output Log</figcaption></figure><br>于是再度深入语法分析模块进行检查，最终发现是Lex在进行匹配时存在隐藏的队列结构的缓冲区（<code>/src/lex.yy.c</code>），这会导致每次产生解析错误后，其后续消息会被作为下一次消息解析的开头，进而再次导致解析错误。不过，框架代码中也已经定义了用于清除该隐藏缓冲区的函数<code>yylex_destroy</code>，因此只需在<code>/src/parser.c</code>文件中，开始进行语法分析前调用上述函数，清空Lex的隐藏缓冲区即可。随后再次测试即可得到正确的结果。</p>
<h2 id="四、结果分析"><a href="#四、结果分析" class="headerlink" title="四、结果分析"></a>四、结果分析</h2><p>在结果测试部分，分别进行了如下测试：</p>
<h5 id="GET-HEAD-POST请求"><a href="#GET-HEAD-POST请求" class="headerlink" title="GET&#x2F;HEAD&#x2F;POST请求"></a>GET&#x2F;HEAD&#x2F;POST请求</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/get.jpeg"
                      alt="HTTP GET" title="HTTP GET请求"
                ><figcaption>HTTP GET</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/head.jpeg"
                      alt="HTTP HEAD" title="HTTP HEAD请求"
                ><figcaption>HTTP HEAD</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/post.jpeg"
                      alt="HTTP POST" title="HTTP POST请求"
                ><figcaption>HTTP POST</figcaption></figure></p>
<h5 id="未实现方法PUT-WRONG"><a href="#未实现方法PUT-WRONG" class="headerlink" title="未实现方法PUT&#x2F;WRONG"></a>未实现方法PUT&#x2F;WRONG</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/501_put.jpeg"
                      alt="501 PUT" title="501报错 PUT"
                ><figcaption>501 PUT</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/501_wrong.jpeg"
                      alt="501 WRONG" title="501报错 WRONG"
                ><figcaption>501 WRONG</figcaption></figure></p>
<h5 id="6种格式错误"><a href="#6种格式错误" class="headerlink" title="6种格式错误"></a>6种格式错误</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_1.jpeg"
                      alt="400 1" title="400报错 1"
                ><figcaption>400 1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_2.jpeg"
                      alt="400 2" title="400报错 2"
                ><figcaption>400 2</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_3.jpeg"
                      alt="400 3" title="400报错 3"
                ><figcaption>400 3</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_4.jpeg"
                      alt="400 4" title="400报错 4"
                ><figcaption>400 4</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_5.jpeg"
                      alt="400 5" title="400报错 5"
                ><figcaption>400 5</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/400_6.jpeg"
                      alt="400 6" title="400报错 6"
                ><figcaption>400 6</figcaption></figure></p>
<h5 id="Autolab测试"><a href="#Autolab测试" class="headerlink" title="Autolab测试"></a>Autolab测试</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/15/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week1/autolab.jpeg"
                      alt="Autolab" title="Autolab 自动测试结果"
                ><figcaption>Autolab</figcaption></figure></p>
<h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>大概了解了一下实验环境，学了点正则表达式相关的知识和运用。明白了框架代码中服务器和客户端是如何通过socket进行通信的，以及源码的一些数据结构和程序框架，算是一个简单的入门。</p>
]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程日志 Week2</title>
    <url>/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/</url>
    <content><![CDATA[<h2 id="一、实验概要"><a href="#一、实验概要" class="headerlink" title="一、实验概要"></a>一、实验概要</h2><p>第二周需要实现的功能模块主要有以下几部分。</p>

  <div class="note-large green">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>请求响应模块</p>

    </div>
    <div class="notel-content">
      <p>1.正确响应GET&#x2F;HEAD&#x2F;POST请求，并能建立持久连接<br>2.支持四种错误代码：400，404，501，505<br>3.妥善管理缓冲区，避免缓冲区溢出错误</p>

    </div>
  </div>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>文件错误处理模块</p>

    </div>
    <div class="notel-content">
      <p>1.能够处理文件读写过程中遇到的错误，如权限问题、文件不存在、IO错误等</p>

    </div>
  </div>

  <div class="note-large yellow">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>日志模块</p>

    </div>
    <div class="notel-content">
      <p>1.按“Error Log”格式记录服务器的出错情况<br>2.按“Access Log”的“Common Log Format”格式记录服务器处理的请求<br>3.其它辅助调试的日志记录（不做格式要求）</p>

    </div>
  </div>

<h2 id="二、协议设计"><a href="#二、协议设计" class="headerlink" title="二、协议设计"></a>二、协议设计</h2><h3 id="1-响应生成模块"><a href="#1-响应生成模块" class="headerlink" title="1. 响应生成模块"></a>1. 响应生成模块</h3><p>首先，需要实现对GET、HEAD、POST三种请求的响应生成。</p>
<h4 id="GET响应生成"><a href="#GET响应生成" class="headerlink" title="GET响应生成"></a>GET响应生成</h4><h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><ol>
<li><p>响应数据结构<br>为了实现HTTP GET响应，首先需要了解正确的响应结构是什么样的。如下所示是需要实现的HTTP GET响应结构示意图。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/answer_format.jpeg"
                      alt="GET Answer" title="HTTP GET响应结构"
                ><figcaption>GET Answer</figcaption></figure><br>根据手册要求，响应中必须包含<code>&quot;HTTP/1.1 200 OK\r\n&quot;</code>，而响应实体部分则需从请求文件中获取。因此可以定义响应的结构为一个字符串，具体组成如下。<br><code>&quot;HTTP/1.1 200 OK\r\n&quot; + Data_in_file</code><br>此外，根据手册要求，缓冲区大小应设为<code>8192</code>。</p>
</li>
<li><p>文件状态结构<br>根据手册提示，使用<code>stat</code>函数来获取文件状态，并以此检测文件权限、大小等信息，处理可能产生的文件读写错误。而<code>stat</code>的返回值为一个自定义结构<code>struct stat</code>，该结构定义在头文件<code>sys/stat.h</code>中，其部分重要定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>struct stat</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">mode_t</span>		st_mode;                <span class="comment">/* [XSI] Mode of file (see below) */</span> \</span><br><span class="line"><span class="type">off_t</span>		st_size;                <span class="comment">/* [XSI] file size, in bytes */</span> \</span><br></pre></td></tr></table></figure></div>
<p>其中，<code>st_mode</code>为该文件的模式码，包含该文件的类型、权限信息等重要信息；而<code>st_stze</code>为该文件的大小，可用于判断文件大小是否超限。<br>而对<code>st_mode</code>值的定义，继续深入查看，可以在<code>sys/stat.h</code>和<code>sys/_types/_s_ifmt.h</code>文件中找到对于该值的部分定义如下。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><figcaption><span>st_mode</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file &quot;sys/stat.h&quot; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_ISREG(m)      (((m) &amp; S_IFMT) == S_IFREG)     <span class="comment">/* regular file */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file &quot;sys/_types/_s_ifmt.h&quot; */</span></span><br><span class="line"><span class="comment">/* File type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFMT          0170000         <span class="comment">/* [XSI] type of file mask */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IFREG         0100000         <span class="comment">/* [XSI] regular */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File mode */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXU         0000700         <span class="comment">/* [XSI] RWX mask for owner */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR         0000400         <span class="comment">/* [XSI] R for owner */</span></span></span><br></pre></td></tr></table></figure></div>
<p>根据定义，如果宏<code>S_ISREG(st_mode)</code>返回<code>TRUE</code>，则代表该文件为常规媒体文件，文件类型正确；<br>同时，可以仿照宏<code>S_ISREG(m)</code>，通过表达式<br><code>((st_mode) &amp; S_IRWXU) == S_IRUSR</code><br>定义宏<code>S_ISRFL(m)</code>检查文件的权限，若返回<code>TRUE</code>则代表用户有可读权限，权限类型正确。</p>
</li>
</ol>
<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>要生成针对HTTP GET请求的响应，大体可以分为一下几部分：</p>
<ol>
<li><p>从请求中获取请求文件的<code>URL</code>，并以此设置文件路径<br>若为默认<code>URL</code>，则将路径设为默认文件路径；<br>若为指定的<code>URL</code>，则根据<code>URL</code>拼接路径；<br>若<code>URL</code>长度超限，返回生成失败。</p>
</li>
<li><p>根据路径打开文件，检查文件权限、大小等信息<br>根据前面解析出的路径尝试获取该文件的<code>stat</code>信息，若获取失败则返回生成失败；<br>比对文件的<code>st_mode</code>，判断其是否为常规媒体类型文件，且用户拥有可读权限，若不符合则返回生成失败；<br>获取文件的<code>st_size</code>，计算其与<code>200 OK</code>响应的长度和是否小于缓冲区长度，若不符合则返回生成失败。</p>
</li>
<li><p>将文件内容和<code>200 OK</code>响应拷贝至缓冲区中作为响应<br>打开该文件，打开失败则返回生成失败；<br>清空缓冲区，将<code>200 OK</code>响应拷贝至缓冲区中，再将文件内容拼接至缓冲区中，生成响应。</p>
</li>
</ol>
<p>根据以上设计，可以绘制出生成HTTP GET响应的流程图。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/GET_generate.jpeg"
                      alt="GET Generate" title="GET响应生成流程"
                ><figcaption>GET Generate</figcaption></figure></p>
<h4 id="HEAD响应生成"><a href="#HEAD响应生成" class="headerlink" title="HEAD响应生成"></a>HEAD响应生成</h4><p>HTTP HEAD请求的响应生成与GET类似，只不过在最后生成响应时只需包含<code>200 OK</code>响应的内容即可。<br>因此，容易得到HTTP HEAD响应的流程图如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/HEAD_generate.jpeg"
                      alt="HEAD Generate" title="HEAD响应生成流程"
                ><figcaption>HEAD Generate</figcaption></figure></p>
<h4 id="POST响应生成"><a href="#POST响应生成" class="headerlink" title="POST响应生成"></a>POST响应生成</h4><p>HTTP POST响应的生成则更为简单，根据手册要求，只需将请求echo回客户端即可。而这一功能在Week 1中已经成功实现了，因此此处不再讨论。</p>
<h3 id="2-服务器响应模块"><a href="#2-服务器响应模块" class="headerlink" title="2. 服务器响应模块"></a>2. 服务器响应模块</h3><p>随后，还需要对Week 1中实现的服务器响应模块进行一定更改，以支持对GET、HEAD、POST请求的分别响应，以及对404、505这两种新错误的响应。<br>此次实验不需要在此模块中定义新的数据结构，因此跳过数据结构设计部分。</p>
<h5 id="协议规则设计-1"><a href="#协议规则设计-1" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>根据实验要求，响应模块总共需要支持7种不同类型的响应，分别如下：</p>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-1"></i><p>HTTP GET 请求</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-2"></i><p>HTTP HEAD 请求</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-3"></i><p>HTTP POST 请求</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-4"></i><p>400 Bad Request 错误</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-5"></i><p>501 Not Implement 错误</p>

  </div>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-square-6"></i><p>404 Not Found 错误</p>

  </div>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-square-7"></i><p>505 Version not supported 错误</p>

  </div>
<p>对于GET、HEAD、POST请求，响应的主要功能已经实现，只需按照本次实验的要求对其进行分别处理，并通过前面设计的响应生成模块生成对应的响应内容，存储至缓冲区中发送即可；<br>对于400和501错误，前面已经实现，无需更改；<br>对于505错误，要求如下：<br>请求消息解析完成后，将其HTTP版本与服务器支持HTTP版本(<code>HTTP/1.1</code>)进行比对，若版本不匹配，则响应<code>&quot;HTTP/1.1 505 HTTP Version not supported\r\n\r\n&quot;</code>。<br>对于404错误，要求如下：<br>若在GET和HEAD请求的响应生成模块中，对文件进行获取和读入时出现任何错误，导致响应生成失败，程序返回<code>HTTP_FAIL</code>，则响应<code>&quot;HTTP/1.1 404 Not Found\r\n\r\n&quot;</code>。</p>
<h3 id="3-日志记录模块"><a href="#3-日志记录模块" class="headerlink" title="3. 日志记录模块"></a>3. 日志记录模块</h3><p>最后，还需要按照给定格式记录服务器响应请求的<code>Access Log</code>，和服务器错误的<code>Error Log</code>。此外，也可以根据自己的需求记录相关日志信息，无格式要求。</p>
<h5 id="数据结构设计-1"><a href="#数据结构设计-1" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>显然，为了顺利记录日志，需要在程序中对文件进行读写操作。在C语言中使用<code>FILE</code>结构即可定义一个文件，因此无需自行定义相关数据结构。<br>随后，还需理清Apache手册中<code>Access Log</code>和<code>Error Log</code>的格式。经过阅读，并按实验的实际情况作出适当调整后，可以得到格式如下。</p>
<p><b><code>Access Log: IP:Port - frank [Time] &quot;http_method URL http_version&quot; 200 OK body_size</code></b></p>
<p><b><code>Error Log: [Time] [core:error] [client: IP:Port] error_info</code></b></p>
<p>注：IP:Port在本实验环境中统一为<code>127.0.0.1:9999</code></p>
<p>对于<code>Access Log</code>，使用之前分析或定义过的数据结构即可完成日志的生成和写入，无需进一步分析；<br>而对于<code>Error Log</code>，可以发现在其最后需要输出当前错误类型对应的错误信息<code>error_info</code>。由于错误种类较多，错误信息均为字符串，且需考虑到程序对支持其它错误的可扩展性，因此在此可以通过自定义枚举和查找表数据结构来更便捷的生成错误日志。<br>首先，需要设计一个枚举类型，用于存储每种错误类型，形如如下伪代码。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>ERROR TYPE</span></figcaption><table><tr><td class="code"><pre><span class="line">enum ERROR_TYPE</span><br><span class="line">    ERROR_1,</span><br><span class="line">	ERROR_2,</span><br><span class="line">	ERROR_3,</span><br><span class="line">	......</span><br></pre></td></tr></table></figure></div>
<p>随后，再定义一个字符串数组，按前面枚举类型的顺序依次存储对应的错误信息，形如如下伪代码。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>ERROR INFO TABLE</span></figcaption><table><tr><td class="code"><pre><span class="line">log_error_1[] = Error_Info_1</span><br><span class="line">log_error_2[] = Error_Info_2</span><br><span class="line">log_error_3[] = Error_Info_3</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">error_table[] = &#123;</span><br><span class="line">	log_error_1,</span><br><span class="line">	log_error_2,</span><br><span class="line">	log_error_3,</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如此，便得到了一个错误信息的查找表。通过<code>error_table[ERROR_TYPE]</code>就能得到对应的错误信息，以结构化生成相应的日志记录。同时，可以便捷、快速的扩展新的错误类型，只需为其添加<code>ERROR_TYPE</code>和对应的<code>log_error</code>，并插入至<code>error_table</code>的正确位置即可。</p>
<h5 id="协议规则设计-2"><a href="#协议规则设计-2" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>在完成日志记录格式和相关数据结构的定义后，很快便能完成对日志模块的设计。只需编写两个日志记录函数，用于参数化写入日志记录，并在需要记录的地方调用即可。此外，对于自定义的日志记录，直接在需要记录处对日志文件进行写入即可。</p>
<h3 id="4-缓冲区管理"><a href="#4-缓冲区管理" class="headerlink" title="4. 缓冲区管理"></a>4. 缓冲区管理</h3><h5 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h5><p>实验手册中要求对缓冲区进行合理的管理，以避免通信过程中出现缓冲区溢出错误。按照手册要求，共有3种潜在的缓冲区溢出风险。</p>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-1"></i><p>URL长度超限</p>

  </div>

  <div class="note p-4 mb-4 rounded-small green icon-padding">
    <i class="note-icon fa-solid fa-square-2"></i><p>响应内容长度超限</p>

  </div>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-square-3"></i><p>请求头部长度超限</p>

  </div>
<p>对于前两种情况，在先前的设计中已经进行了相关的设计和说明，不再赘述，此处只对请求头部长度超限的情况进行设计。<br>根据要求，请求头部大小应不超过<code>8192</code>字节。因此首先需要将缓冲区大小更改为<code>8192</code>字节。随后，在从客户端接收到请求后，只需对接收到的消息长度进行判断，若等于<code>8192</code>（由于缓冲区长度为<code>8192</code>，故接收消息的长度最大也为<code>8192</code>，但当长度等于<code>8192</code>时，消息占据了最后一位空字符位，即长度超限，会产生缓冲区溢出错误），则不进行词法分析，直接返回400错误。</p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a>三、协议实现</h2><h3 id="1-响应生成模块-1"><a href="#1-响应生成模块-1" class="headerlink" title="1. 响应生成模块"></a>1. 响应生成模块</h3><p>前面提到过，在此模块中需要对<code>GET</code>请求和<code>HEAD</code>请求生成对应的响应，而<code>POST</code>响应的生成与Week 1中已实现的一致，因此无需再作更改。同时，对于<code>HEAD</code>请求，其整体处理流程和<code>GET</code>请求的一致，只需在最终生成响应时去掉拼接文件实体的部分即可。因此下面只给出对<code>GET</code>请求生成响应的详细实现过程。</p>
<h4 id="URL解析部分"><a href="#URL解析部分" class="headerlink" title="URL解析部分"></a>URL解析部分</h4><p>首先，需要定义函数来对请求中的URL进行解析，以生成文件路径。请求文件的URL包括两部分，第一部分是服务器的根目录（在此实验中为<code>./static_site</code>），第二部分为请求行中提供的<code>uri</code>。当<code>uri</code>为<code>/</code>时，使用默认文件路径（<code>/index.xml</code>）与根目录拼接得到<code>URL</code>，否则使用请求给出的<code>uri</code>（<code>request-&gt;http_uri</code>）与根目录拼接生成<code>URL</code>，解析<code>URL</code>成功后应返回<code>HTTP_SUCC</code>。而在生成时，还应注意<code>URL</code>的长度不得超限，若超限则应返回<code>HTTP_FAIL</code>。<br>根据以上描述，可以得到<code>URL</code>解析函数的伪代码如下。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Get URL Function</span></figcaption><table><tr><td class="code"><pre><span class="line">root = &quot;./static_site&quot;</span><br><span class="line">file = &quot;/index.xml&quot;</span><br><span class="line"></span><br><span class="line">get_url(request, url)</span><br><span class="line">	IF request-&gt;http_uri == &quot;/&quot;		// 默认URL</span><br><span class="line">		THEN url = root + file</span><br><span class="line">		RETURN HTTP_SUCC</span><br><span class="line">	ELSE IF root.length + request-&gt;http_uri.length &lt; max size of URL	// 请求给出uri</span><br><span class="line">		THEN url += root + request-&gt;http_uri</span><br><span class="line">        RETURN HTTP_SUCC;</span><br><span class="line">	ELSE		// URL长度超限</span><br><span class="line">        RETURN HTTP_FAIL;</span><br><span class="line">	END IF</span><br></pre></td></tr></table></figure></div>

<h4 id="响应生成部分"><a href="#响应生成部分" class="headerlink" title="响应生成部分"></a>响应生成部分</h4><p>随后，根据解析出的URL，可以开始获取对应文件并生成响应。此处的设计流程在协议设计部分已经有了详细的说明，也给出了清晰的流程图，故不再赘述，只给出一些实现时需要掌握的框架代码细节。<br>1.	使用<code>stat</code>结构变量存储文件信息；<br>2.	文件属性<code>st_mode</code>和文件内容长度<code>st_size</code>均应从<code>stat</code>结构中获取；<br>3.	使用<code>open</code>函数根据<code>URL</code>打开文件；<br>4.	使用<code>read</code>函数从文件中读取内容至缓冲区；<br>5.	若响应生成成功，应返回<code>HTTP_SUCC</code>，若在上述任一步骤中出错，应返回<code>HTTP_FAIL</code>。</p>
<p>由此，可以顺利得到<code>GET</code>请求的响应生成函数伪代码如下。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>GET Answer Generator</span></figcaption><table><tr><td class="code"><pre><span class="line">_200 = &quot;HTTP/1.1 200 OK\r\n&quot;</span><br><span class="line"></span><br><span class="line">http_get(URL, buf)</span><br><span class="line">	GET file info BY stat()</span><br><span class="line">	IF stat() FAILED	// gei info failed</span><br><span class="line">		THEN RETURN HTTP_FAIL</span><br><span class="line">	END IF</span><br><span class="line"></span><br><span class="line">	IF !S_ISREG(st_mode) OR !S_ISRFL(st_mode)	// type or permission wrong</span><br><span class="line">		THEN RETURN HTTP_FAIL</span><br><span class="line">	END IF</span><br><span class="line"></span><br><span class="line">	IF _200.length + st_size &gt;= BUF_SIZE	// file too large</span><br><span class="line">		THEN RETURN HTTP_FAIL</span><br><span class="line">	END IF</span><br><span class="line"></span><br><span class="line">	OPEN file BY open()</span><br><span class="line">	IF open() FAILED	// open file failed</span><br><span class="line">		THEN RETURN HTTP_FAIL</span><br><span class="line">	END IF</span><br><span class="line"></span><br><span class="line">	READ file TO body BY read()</span><br><span class="line">	buf = _200 + body</span><br><span class="line">	RETURN HTTP_SUCC</span><br></pre></td></tr></table></figure></div>
<p>根据以上伪代码，就可以顺利的实现HTTP GET响应的生成，而稍加修改后就能实现HTTP HEAD响应的生成。</p>
<h3 id="2-服务器响应模块-1"><a href="#2-服务器响应模块-1" class="headerlink" title="2. 服务器响应模块"></a>2. 服务器响应模块</h3><p>对于服务器响应模块，只需将Week 1已实现的模块进行更改，将<code>GET</code>、<code>HEAD</code>、<code>POST</code>三种请求分开响应，并额外增加对505错误和404错误的判断和响应即可。<br>1.	对于三种不同请求的响应，在Week 1中已经阐述了如何判断，只需将其拆分为单独判断即可；<br>2.	对于505错误的判断，只需在解析后得到的HTTP版本号（存储在<code>request-&gt;http_vision</code>中）与支持版本号（<code>HTTP/1.1</code>）进行匹配，若匹配失败则产生505错误，响应对应的错误信息；<br>3.	而对于404错误的判断则较为简单，如果在调用<code>GET</code>响应生成函数或<code>HEAD</code>响应生成函数时返回了<code>HTTP_FAIL</code>，则产生404错误，响应对应的错误信息。<br>由此，可以绘制服务器响应模块的响应结构图如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/server.jpeg"
                      alt="Server Answer" title="服务器响应结构图"
                ><figcaption>Server Answer</figcaption></figure><br>根据结构图，就能顺利的完成对服务器响应模块的修改和实现。</p>
<h3 id="3-日志记录模块-1"><a href="#3-日志记录模块-1" class="headerlink" title="3. 日志记录模块"></a>3. 日志记录模块</h3><p>对于日志记录模块，前面的设计已经较为详尽，在此补充一些实现细节。<br>1.	使用fprintf()函数可以向日志文件中写入数据，而在每次写入后，还应调用fflush()函数来刷新缓冲区，以保证写入内容的正确性；<br>2.	对于<code>Access Log</code>记录函数，其请求方法，URI和HTTP版本等信息，应使用<code>Request</code>结构体中的<code>http_method</code>、<code>http_uri</code>、<code>http_version</code>来生成，而文件大小的部分则应使用<code>stat</code>结构中的<code>file_size</code>来生成；<br>3.	对于<code>Error Log</code>记录函数，则只需传入对应的<code>ERROR_TYPE</code>，便可以完成日志记录的生成。<br>由此，可以得到两种日志记录的伪代码如下。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Log Recored</span></figcaption><table><tr><td class="code"><pre><span class="line">ok_recored(request, file_stat)</span><br><span class="line">	IF file_stat != NULL</span><br><span class="line">		THEN body_size = file_stat-&gt;file_size</span><br><span class="line">	ELSE</span><br><span class="line">		THEN body_size = 0;</span><br><span class="line">	END IF</span><br><span class="line"></span><br><span class="line">	WRITE INTO log BY ffprintf:</span><br><span class="line">		127.0.0.1:9999 - frank [Time] &quot;request-&gt;http_method request-&gt;http_uri request-&gt;http_version&quot; 200 OK body_size</span><br><span class="line"></span><br><span class="line">	CALL fflush</span><br><span class="line"></span><br><span class="line">error_record(error_type)</span><br><span class="line">	WRITE INTO log BY ffprintf:</span><br><span class="line">		[Time] [core:error] [client: 127.0.0.1:9999] error_table[error_type]</span><br><span class="line">	</span><br><span class="line">	CALL fflush</span><br></pre></td></tr></table></figure></div>
<p>随后，只需在正确的地方调用以上两种日志记录函数便可以完成日志的记录工作。</p>
<h3 id="4-缓冲区管理-1"><a href="#4-缓冲区管理-1" class="headerlink" title="4. 缓冲区管理"></a>4. 缓冲区管理</h3><p>前面提到过，如果在接收HTTP请求消息后发现请求头部过长（超过<code>8192</code>字节），则不对其进行词法分析，直接返回400错误。因此，应在接收消息后、词法分析前对消息的长度进行判断，并决定是否响应400错误。<br>在框架代码中，<code>readret</code>用于存储读取到的文件长度，而<code>BUF_SIZE</code>则存储了缓冲区的最大长度（<code>8192</code>），因此容易写出此部分的伪代码如下。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Check File Size</span></figcaption><table><tr><td class="code"><pre><span class="line">WHILE(...)	// 框架函数中接收消息的循环</span><br><span class="line">	IF readret &gt;= BUF_SIZE</span><br><span class="line">		THEN answer 400 Bad Request		// 使用服务器响应模块的对应功能实现</span><br><span class="line">		BREAK WHILE		// 跳出消息读取循环，等待接收下一次请求</span><br><span class="line">	END IF</span><br></pre></td></tr></table></figure></div>
<p>由此，就能成功对长度超限的请求报错，以避免出现缓冲区溢出错误。</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>根据功能要求，分别需要对<code>GET</code>、<code>HEAD</code>、<code>POST</code>请求进行测试，对<code>400</code>、<code>404</code>、<code>501</code>、<code>505</code>四种错误进行测试，以及对因请求头部过长而产生的<code>400</code>错误进行测试，并查看是否正确生成了相应的日志记录。<br>各部分测试结果如下：</p>
<h5 id="GET-HEAD-POST请求"><a href="#GET-HEAD-POST请求" class="headerlink" title="GET&#x2F;HEAD&#x2F;POST请求"></a>GET&#x2F;HEAD&#x2F;POST请求</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/get.jpeg"
                      alt="HTTP GET" title="HTTP GET请求"
                ><figcaption>HTTP GET</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/head.jpeg"
                      alt="HTTP HEAD" title="HTTP HEAD请求"
                ><figcaption>HTTP HEAD</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/post.jpeg"
                      alt="HTTP POST" title="HTTP POST请求"
                ><figcaption>HTTP POST</figcaption></figure></p>
<h5 id="四种错误请求"><a href="#四种错误请求" class="headerlink" title="四种错误请求"></a>四种错误请求</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/400.jpeg"
                      alt="400 ERROR" title="400报错"
                ><figcaption>400 ERROR</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/404.jpeg"
                      alt="404 ERROR" title="404报错"
                ><figcaption>404 ERROR</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/501.jpeg"
                      alt="501 ERROR" title="501报错"
                ><figcaption>501 ERROR</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/505.jpeg"
                      alt="505 ERROR" title="505报错"
                ><figcaption>505 ERROR</figcaption></figure></p>
<h5 id="请求头部超限的请求"><a href="#请求头部超限的请求" class="headerlink" title="请求头部超限的请求"></a>请求头部超限的请求</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/too_large.jpeg"
                      alt="Request Too Large" title="请求头部超限"
                ><figcaption>Request Too Large</figcaption></figure></p>
<h5 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/log.jpeg"
                      alt="Log" title="日志记录"
                ><figcaption>Log</figcaption></figure></p>
<h5 id="Autolab测试"><a href="#Autolab测试" class="headerlink" title="Autolab测试"></a>Autolab测试</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/22/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week2/autolab.jpeg"
                      alt="Autolab" title="Autolab 自动测试结果"
                ><figcaption>Autolab</figcaption></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>了解并实践了如何根据请求查找服务器中的文件，并按正确的格式为客户端发送响应，对网络通信有了更清晰的认识；同时，新增了对404和505两种错误类型的判断和响应，为服务器添加了更多功能；在响应过程中涉及到许多对缓冲区的操作，对缓冲区管理有了更好的掌握；新增了日志模块，了解了如何通过日志记录服务器所执行的各种操作，对分析程序行为有很大帮助。</p>
]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程日志 Week3</title>
    <url>/2024/05/29/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week3/</url>
    <content><![CDATA[<h2 id="一、实验概要"><a href="#一、实验概要" class="headerlink" title="一、实验概要"></a>一、实验概要</h2><p>第三周实验只需实现一个重要的功能：HTTP pipeline。<br>具体来说，服务器需要按照RFC2616规定的顺序处理HTTP的并发请求。同时，对于错误的请求，服务器响应错误后不会影响后续消息的响应。</p>
<h2 id="二、协议设计"><a href="#二、协议设计" class="headerlink" title="二、协议设计"></a>二、协议设计</h2><h3 id="1-Pipeline模块"><a href="#1-Pipeline模块" class="headerlink" title="1. Pipeline模块"></a>1. Pipeline模块</h3><p>首先，根据RFC2616的规定，应先处理先到达的请求，后处理后达到的请求。而在实验的环境中，体现为先处理整体请求输入中最靠前的请求，再逐个向后进行处理。<br>下面对此模块进行设计。</p>
<h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>在第一周实验中，给出过HTTP请求的结构如下所示。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/29/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week3/HTTPRequest.jpeg"
                      alt="HTTP Request" title="HTTP 请求报文结构"
                ><figcaption>HTTP Request</figcaption></figure><br>由于在本实验中所支持的请求均不包含请求数据的部分，因此在服务器处理至最后的回车符和换行符后即可认为一个请求已经结束。经过观察容易发现，在请求报文的最后会出现<code>&quot;\r\n\r\n&quot;</code>这一特殊字符串，且在请求报文的其它地方均不会出现此字符串，因此可将其作为检测不同请求的分隔符，来对不同的请求报文进行区分。</p>
<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>在清楚了如何识别不同请求报文的分隔符后，只需简单的根据分隔符将所有请求拆分开，再对每个请求进行响应即可。在对消息进行拆分时，应按如下步骤进行。</p>
<ol>
<li>读取全部请求报文，从头开始进行拆分；</li>
<li>记录当前的处理位置，若超出报文长度则代表拆分完毕；</li>
<li>通过串匹配算法匹配未处理串中第一个分隔符的末尾位置，即为当前请求的结束位置；</li>
<li>计算匹配长度；</li>
<li>根据匹配长度提取当前请求，并传入服务器响应模型进行响应；</li>
<li>更新当前处理位置为请求结束位置</li>
<li>循环处理直至拆分完毕。</li>
</ol>
<p>根据以上设计，可以绘制拆分流程图如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/29/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week3/separate.jpeg"
                      alt="Pipeline Separate" title="Pipeline请求拆分流程图"
                ><figcaption>Pipeline Separate</figcaption></figure></p>
<h3 id="2-客户端接收模块"><a href="#2-客户端接收模块" class="headerlink" title="2. 客户端接收模块"></a>2. 客户端接收模块</h3><p>需要注意，由于在先前框架代码的设计中，客户端每发送一次请求报文只会接受一个响应，而在本次实验中服务器会尝试发送多个响应。因此还需要对客户端程序进行一定修改，使其支持对多个响应的连续接收。</p>
<h5 id="协议规则设计-1"><a href="#协议规则设计-1" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>这部分的设计比较简单，只需将框架代码中接收响应的模块放在一个循环结构中，每接收到一个合法响应便输出即可。</p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a>三、协议实现</h2><h3 id="1-Pipeline模块-1"><a href="#1-Pipeline模块-1" class="headerlink" title="1. Pipeline模块"></a>1. Pipeline模块</h3><p>在对Pipeline模块进行实现时，除去对前述流程的实现外，缓冲区的管理也是一个比较重要的问题。<br>本模块的处理过程中需要存储三部分内容：全部请求报文、单次请求报文和单次请求的响应。因此，可以设置3个不同的缓冲区：<code>buf_all</code>、<code>buf_recv</code>、<code>buf_send</code>，分别存储上述三种数据。也正因此，本次实验中还需对原先的服务器响应模块进行部分修改，以匹配新的缓冲区设计。<br>根据前面的流程图和对缓冲区的新设计，可以得到Pipeline模块的伪代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Pipeline Module</span></figcaption><table><tr><td class="code"><pre><span class="line">BUFFER buf_all, buf_recv, buf_send</span><br><span class="line">sep = &quot;\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">RECV FROM CLIENT TO buf_all</span><br><span class="line">WHILE start_loc &lt; buf_all.length</span><br><span class="line">    end_loc = MATCH sep END CHAR IN buf_all + start_loc</span><br><span class="line">    length = end_loc - start_loc + 1</span><br><span class="line"></span><br><span class="line">    IF length &gt; left_length</span><br><span class="line">        THEN BREAK</span><br><span class="line">    END IF</span><br><span class="line"></span><br><span class="line">    COPY buf_all FROM start_loc TO end_loc INTO buf_recv</span><br><span class="line">    start_loc += length</span><br><span class="line"></span><br><span class="line">    CALL SERVER ANSWEERING MODULE</span><br><span class="line">        SAVE ANSWER IN buf_send</span><br><span class="line">        SEND buf_send</span><br><span class="line">    END CALL</span><br><span class="line">END WHILE</span><br></pre></td></tr></table></figure></div>
<p>由此便可完成Pipeline模块的实现。</p>
<h3 id="2-客户端接收模块-1"><a href="#2-客户端接收模块-1" class="headerlink" title="2. 客户端接收模块"></a>2. 客户端接收模块</h3><p>此模块的实现只需在框架代码上进行少量更改即可。框架代码可以用如下伪代码表示。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Client Recv Old</span></figcaption><table><tr><td class="code"><pre><span class="line">IF RECV FROM SERVER TO buf AND buf.length &gt; 1</span><br><span class="line">    THEN PRINT buf</span><br></pre></td></tr></table></figure></div>
<p>在此只需将<code>if</code>判断语句更改为<code>while</code>循环语句，并进行一些细节上的匹配即可。更改后可以用如下伪代码表示。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Client Recv New</span></figcaption><table><tr><td class="code"><pre><span class="line">WHILE RECV FROM SERVER TO buf AND buf.length &gt; 1</span><br><span class="line">    THEN PRINT buf</span><br></pre></td></tr></table></figure></div>
<p>至此，可以完成对客户端接收多个响应功能的实现。</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><h5 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h5><p>框架代码中给出了一个可用于测试的<code>request_pipeline</code>文件，本次实验实现的程序也可以对该测试文件得到正确的结果。但该文件内容较长，不易于展示，因此这里自行编写一个较为简单的测试文件<code>sample_pipeline</code>，其中包含3个连续的HTTP请求，分别为未实现请求，格式错误的请求，以及<code>HTTP GET</code>请求，以此验证服务器能否正确拆分并响应请求，且对错误请求的处理不会影响后续请求的处理。<br>测试结果如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/29/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week3/test.jpeg"
                      alt="Test Result" title="本地测试结果"
                ><figcaption>Test Result</figcaption></figure><br>可以看到，服务器对每个请求都进行了正确的响应，且响应顺序正确。<br>此外，根据日志记录也可以看出，服务器对每个拆分出的请求都生成并发送了正确的响应。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/29/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week3/log.jpeg"
                      alt="Log Recorded" title="响应日志记录"
                ><figcaption>Log Recorded</figcaption></figure></p>
<h5 id="Autolab测试"><a href="#Autolab测试" class="headerlink" title="Autolab测试"></a>Autolab测试</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/29/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week3/autolab.jpeg"
                      alt="Autolab" title="Autolab 自动测试结果"
                ><figcaption>Autolab</figcaption></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>了解并成功实现了对连续HTTP请求的拆分和分别处理，对HTTP请求的结构有了更进一步的认识；加深了对缓冲区管理的意识和了解程度，明白了某些复杂功能需要基于良好的缓冲区设计；更深入的理解了客户端和服务器间的通信方式，并成功实现了客户端对多个连续响应的接收和打印。</p>
]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程日志 Week4</title>
    <url>/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/</url>
    <content><![CDATA[<h2 id="一、实验概要"><a href="#一、实验概要" class="headerlink" title="一、实验概要"></a>一、实验概要</h2><p>第四周实验中，需要让服务器在等待一个客户端发送下一个请求时，能够同时处理来自其它客户端的请求，进而实现对多个并发的客户端的同时处理。<br>具体而言，并发处理需要通过select()方法实现，并支持最多1024个并发连接。<br>此外，如果某些客户端在通信过程中“暂停”，或是出现错误，服务器应不受该客户端影响，继续为其它客户端提供服务。</p>
<h2 id="二、协议设计"><a href="#二、协议设计" class="headerlink" title="二、协议设计"></a>二、协议设计</h2><h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>在本次实验中，要求使用select()方法实现并发处理。select是一个用于监听文件状态的函数，函数会阻塞进程并持续监听所有文件描述符编号小于其首个参数<code>MAX_FD</code>的文件描述符，直至某些文件描述符状态发生改变，例如某文件进入“读就绪”状态，函数便会返回就绪文件的数量，并将改变的文件描述符<code>fd</code>加入其第二个参数<code>READ_FD_SET</code>(可读文件描述符集合)。而在实验中，每个客户端和服务器的<code>socket</code>也是一个可读文件，因此通过select函数监听所有新增的可读文件便可以接收到所有发送请求的客户端socket。</p>
<p>同时，还需要了解<code>fd_set</code>结构体的组织方式和相关操作，以便后续的设计和实现。<code>fd_set</code>以位图的形式存储了一个文件描述符集合的某种状态，每一位均对应一个文件描述符，而该位的<code>0/1</code>值便对应着该文件描述符的特定状态情况。由此，只需不断通过select方法监听客户端和服务器socket的状态集合，再遍历集合来检查每个客户端socket是否活跃，即可得到所有与服务器建立并发连接的客户端socket的文件描述符。</p>
<p>此外，为了正确的与客户端建立连接并通信，还需要组织一个socket数组，用于储存所有经过前述步骤，与服务器建立连接的客户端socket。至此，就能顺利得到所有与服务器建立并发连接的客户端socket，进而可以对其请求进行处理和响应。</p>
<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>在掌握了以上结构的定义后，便可以按如下步骤来对并发的客户端请求进行接收、管理和响应：</p>
<ol>
<li>使用select方法监听客户端和服务器fd；</li>
<li>获取活跃fd，据此获得待连接客户端socket的fd，并加入已连接fd_set中；</li>
<li>根据已连接fd_set中的fd获取所有已连接客户端socket，并组织一个在socket集合中；</li>
<li>遍历socket集合，对每个客户端接收并响应一次请求，并将其移出连接集合；</li>
<li>循环执行上述步骤，不断连接并逐个响应所有发送请求的客户端，以此实现并发处理的效果。</li>
</ol>
<p>根据以上设计，可以得到并发处理模块的处理流程图如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/multi.jpeg"
                      alt="Multi-Client Answering" title="多客户端并发响应流程图"
                ><figcaption>Multi-Client Answering</figcaption></figure></p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a>三、协议实现</h2><p>为了实现前面的协议设计，还需要清楚如何正确的对<code>fd_set</code>进行管理。在本实验环境中，可以通过宏定义来进行，以下是此次实验中使用到的部分宏定义。</p>
<ol>
<li>FD_ZERO(&amp;fd_set): 将集合中所有fd状态清零（设为不活跃）;</li>
<li>FD_SET(fd, &amp;fd_set): 设置fd在集合中的状态为活跃;</li>
<li>FD_CLR(fd, &amp;fd_set): 将fd在集合中的状态清零;</li>
<li>FD_ISSET(fd, &amp;fd_set): 检查fd在集合中状态是否活跃，若活跃返回1，否则返回0。</li>
</ol>
<p>此外，还需注意将socket集合大小设为1024，并在将已连接客户端socket加入socket集合时判断客户端数量是否超限，以满足实验对最大连接数为1024的要求。</p>
<p>由此，就可以根据流程图编写伪代码，并成功实现客户端并发处理模块。伪代码如下。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>Multi-Client Answering</span></figcaption><table><tr><td class="code"><pre><span class="line">fd_set ready_set, pos_set</span><br><span class="line">int client_set[1024]</span><br><span class="line"></span><br><span class="line">CLEAR ready_set</span><br><span class="line">CLEAR pos_set</span><br><span class="line">ADD server_fd TO ready_set</span><br><span class="line">SET ALL client_set[i] = -1</span><br><span class="line"></span><br><span class="line">LOOP</span><br><span class="line">    COPY ready_set TO pos_set</span><br><span class="line">    CALL select, SET client_num, pos_set</span><br><span class="line">    IF client_num &lt; 0</span><br><span class="line">        select ERROR</span><br><span class="line">        BREAK LOOP</span><br><span class="line">    ELSE IF client_num == 0</span><br><span class="line">        WAIT</span><br><span class="line">        CONTINUE LOOP</span><br><span class="line">    END IF</span><br><span class="line"></span><br><span class="line">    IF server_fd IS IN pos_set</span><br><span class="line">        THEN ACCEPT client_socket</span><br><span class="line">            FIND -1 IN client_set</span><br><span class="line">                ADD client_socket TO client_set</span><br><span class="line">                ADD client_fd TO ready_set</span><br><span class="line">    END IF</span><br><span class="line"></span><br><span class="line">    FOR EACH socket IN client_set</span><br><span class="line">        RECV REQUEST AND ANSWER</span><br><span class="line">        IF ANY ERROR</span><br><span class="line">            THEN CLOSE socket</span><br><span class="line">                CONTINUE</span><br><span class="line">        END IF</span><br><span class="line">        CLOSE socket</span><br><span class="line">        REMOVE fd FROM ready_set</span><br><span class="line">        REMOVE socket FROM client_set</span><br><span class="line">END LOOP</span><br></pre></td></tr></table></figure></div>

<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>本次实验的本地测试和结果分析部分要求使用Apache Bench来进行性能测试，并同时对第三周的部分进行测试，通过比较分析本次实验实现模块的作用。</p>
<h5 id="AB测试"><a href="#AB测试" class="headerlink" title="AB测试"></a>AB测试</h5><p>根据实验要求，使用Apache Bench测试在1000个HTTP请求下第三和第四周程序的响应时间。同时，分别使用10，100，1000个客户端并行发送请求，以体现支持多客户端并行后的特点。</p>
<ol>
<li><p>10个客户端并行<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/1000-10-3.jpeg"
                      alt="10 Week 3" title="第三周程序性能"
                ><figcaption>10 Week 3</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/1000-10-4.jpeg"
                      alt="10 Week 4" title="第四周程序性能"
                ><figcaption>10 Week 4</figcaption></figure></p>
</li>
<li><p>100个客户端并行<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/1000-100-3.jpeg"
                      alt="100 Week 3" title="第三周程序性能"
                ><figcaption>100 Week 3</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/1000-100-4.jpeg"
                      alt="100 Week 4" title="第四周程序性能"
                ><figcaption>100 Week 4</figcaption></figure></p>
</li>
<li><p>1000个客户端并行<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/1000-1000-3.jpeg"
                      alt="1000 Week 3" title="第三周程序性能"
                ><figcaption>1000 Week 3</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/1000-1000-4.jpeg"
                      alt="1000 Week 4" title="第四周程序性能"
                ><figcaption>1000 Week 4</figcaption></figure></p>
</li>
</ol>
<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>从响应时间可以发现，在整体请求数量为1000的情况下，支持多客户端并发处理的程序性能上的整体表现其实弱于仅支持pipeline的程序。这可能是由于在为每个客户端建立连接时需要大量循环扫描socket集合，以寻找空位存储该客户端socket。同时，并发处理模块对每个客户端都采用仅接收一次请求就关闭连接，等待后续有请求时再建立连接的连接方式，而非为每个客户端建立持久连接，如此频繁的建立和断开连接也会大量较大的时间开销。<br>但值得注意的是，随着并发客户端数量的上升，第四周程序和第三周程序间的差距在不断缩小，第四周的性能表现也逐渐变好。因此，在更大规模的HTTP请求和并发客户端（超过实验要求的1024个客户端连接）的情况下，可以推测支持并发处理模块的程序最终会体现出更好的性能，这也是为什么在实际应用场景（请求数量和客户端数量通常远大于实验测试的规模）中通常都会采用支持客户端并发处理的服务器设计。</p>
<h5 id="Autolab测试"><a href="#Autolab测试" class="headerlink" title="Autolab测试"></a>Autolab测试</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/06/03/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week4/autolab.jpeg"
                      alt="Autolab" title="Autolab 自动测试结果"
                ><figcaption>Autolab</figcaption></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>了解并初步掌握了select方法；对fd和fd_set有了更好的掌握，并更深入的理解了socket的结构和处理方式；了解并实践了如何接收并存储多个客户端socket连接，并据此实现了对客户端请求的并发处理；通过测试和分析明白了客户端并行处理模块对服务器性能带来的影响，以及并发处理技术和pipeline技术各自的适用场景。</p>
]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程日志 Week5</title>
    <url>/2024/07/01/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week5/</url>
    <content><![CDATA[<h2 id="一、实验概要"><a href="#一、实验概要" class="headerlink" title="一、实验概要"></a>一、实验概要</h2><p>第五周的实验需要实现服务器对 CGI 请求的支持，并能在 CGI 请求出错时返回对应的错误信息。<br>具体而言，对于 CGI 请求，服务器需要先对其表单的输入、对应 CGI 处理脚本的路径等信息进行解析，并据此配置 CGI 程序的环境变量。随后，服务器需要创建一个新线程，执行外部的 CGI 处理程序来生成响应，获取到响应并发送给客户端。此外，若在整个 CGI 处理过程中出现了任何错误，服务器都向客户端发送 500 报错信息。</p>
<h2 id="二、协议设计"><a href="#二、协议设计" class="headerlink" title="二、协议设计"></a>二、协议设计</h2><h3 id="1-CGI-请求检测模块"><a href="#1-CGI-请求检测模块" class="headerlink" title="1. CGI 请求检测模块"></a>1. CGI 请求检测模块</h3><p>此判断模块依附于 GET&#x2F;HEAD 请求之下，若为这两种请求，则根据请求的 URI 判断是否为 CGI 请求。如果符合 CGI 请求格式，则调用 CGI 处理模块并进行响应，否则按普通的 GET&#x2F;HEAD 请求进行处理。</p>
<h3 id="2-CGI-处理模块"><a href="#2-CGI-处理模块" class="headerlink" title="2. CGI 处理模块"></a>2. CGI 处理模块</h3><p>本模块首先从请求中提取出 CGI 脚本路径等必要信息，并调用环境变量配置模块进行 环境配置。随后，需要开辟一个新线程来运行 CGI 程序，并将 CGI 程序生成的响应存储至缓冲区中，以发送给客户端。此外，若处理过程中产生错误，则应返回错误，以向客户端发送 500 错误信息。</p>
<h5 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>首先，需要了解 CGI 请求的 URI 结构，以便从中提取所需信息。URI 共由 3 部分构成， 为&#x2F;cgi-bin&#x2F;，path 和 query。分别代表脚本的目录路径(也用于标识 CGI 请求)，脚本路径和表单读取数据。具体结构如下方伪代码所示。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>CGI uri</span></figcaption><table><tr><td class="code"><pre><span class="line">Request-&gt;uri:  /cgi-bin/path?query1&amp;query2&amp;……</span><br></pre></td></tr></table></figure></div>

<p>此外，本模块中需要创建新线程来运行CGI程序，因此还需要了解线程管理相关的pid等数据结构。同时，在CGI程序进程和服务器程序进程进行通信时，需要使用到pipe（管道通信）。pipe的数据结构为一个二维int型数组，0和1分别存储标识读端口和写端口的标识号，可以借助如下伪代码进行理解。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>pthread pipe</span></figcaption><table><tr><td class="code"><pre><span class="line">线程1/读端口  my_pipe[0] ========= my_pipe[1]  线程2/写端口</span><br></pre></td></tr></table></figure></div>

<h5 id="协议规则设计"><a href="#协议规则设计" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>了解以上数据结构后，可以按如下步骤进行CGI请求处理：<br>1.	根据URI获取CGI脚本文件路径；<br>2.	调用配置模块配置CGI程序环境变量<br>3.	创建子线程，在子线程中根据脚本路径运行CGI脚本<br>4.	创建管道，子线程将生成的响应写入管道<br>5.	父进程从管道中读取响应<br>6.	父进程将响应写入缓冲区中</p>
<p>根据以上设计，可以得到CGI请求处理流程图如下。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/01/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week5/cgi_handle.jpeg"
                      alt="CGI Handle" title="CGI处理模块"
                ><figcaption>CGI Handle</figcaption></figure></p>
<h3 id="3-环境变量配置模块"><a href="#3-环境变量配置模块" class="headerlink" title="3. 环境变量配置模块"></a>3. 环境变量配置模块</h3><h5 id="数据结构设计-1"><a href="#数据结构设计-1" class="headerlink" title="数据结构设计"></a>数据结构设计</h5><p>此部分需要针对环境变量设计一个数据结构。考虑到每个环境变量都为一个固定格式的字符串，因此采用一个字符串数组在存储环境变量，每个元素均用于存储一个环境变量。<br>此外，此部分中许多环境变量需要从请求的Request结构体中获取，不过这一结构在前面已介绍过，故不再赘述。</p>
<h5 id="协议规则设计-1"><a href="#协议规则设计-1" class="headerlink" title="协议规则设计"></a>协议规则设计</h5><p>此模块主要是对各个环境变量进行配置，需要自行设计的内容较少，且在手册中有十分详细的介绍，不再赘述。</p>
<h2 id="三、协议实现"><a href="#三、协议实现" class="headerlink" title="三、协议实现"></a>三、协议实现</h2><h3 id="1-CGI-请求检测模块-1"><a href="#1-CGI-请求检测模块-1" class="headerlink" title="1. CGI 请求检测模块"></a>1. CGI 请求检测模块</h3><p>在实现上，前面提到过，对CGI请求的检测可以通过URI来完成。若某个HTTP GET&#x2F;HEAD请求的URI起始为“&#x2F;cgi-bin&#x2F;”，则可认为其为一个CGI请求。此外，如果CGI处理模块返回错误，则向客户端响应500错误信息。调用CGI处理模块后的响应、报错等部分则与GET&#x2F;HEAD请求的处理类似。</p>
<h3 id="2-CGI-处理模块-1"><a href="#2-CGI-处理模块-1" class="headerlink" title="2. CGI 处理模块"></a>2. CGI 处理模块</h3><p>首先，需要实现对CGI脚本文件的获取。前面提到过，在请求的URI中可以获取到脚本文件的路径，但其为“&#x2F;cgi-bin&#x2F;path”的形式，直接按此作为路径查找会进入系统文件夹。因此，出于实验的简单考量，可以对路径进行一定修改，使其变为在当前目录下的相对路径，再在实验目录下创建“cgi-bin”文件夹，并将所有脚本文件存储在其中即可。下面给出一个地址转换的例子。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>addr trans</span></figcaption><table><tr><td class="code"><pre><span class="line">Request-&gt;uri:    /cgi-bin/path</span><br><span class="line">Path to Locate:   ./cgi-bin/path</span><br></pre></td></tr></table></figure></div>

<p>其余部分只需参照前面的设计进行实现即可。</p>
<h3 id="3-环境变量配置模块-1"><a href="#3-环境变量配置模块-1" class="headerlink" title="3. 环境变量配置模块"></a>3. 环境变量配置模块</h3><p>环境变量的配置方法在手册中已有详细说明，只需按照手册要求逐条配置，最后将其存储在前面设计的数据结构中，传入CGI处理程序中即可。因此在此不再展开。</p>
<h3 id="4-HTML及CGI脚本文件"><a href="#4-HTML及CGI脚本文件" class="headerlink" title="4. HTML及CGI脚本文件"></a>4. HTML及CGI脚本文件</h3><p>在本次实验中，还需要编写一个HTML文件，来展示一个可以填写表单的网页。此外，还需要编写对应的CGI脚本文件（使用Python编写），来根据表单中获取的数据生成动态网页。这两部分涉及到的知识与Socket编程关系较弱，且这两部分内容也较为简单，因此在此不再展开介绍这两个文件的设计和实现。</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><h5 id="浏览器测试（表单已填写）"><a href="#浏览器测试（表单已填写）" class="headerlink" title="浏览器测试（表单已填写）"></a>浏览器测试（表单已填写）</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/01/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week5/Login1.jpeg"
                      alt="Static Page 1" title="静态网页1"
                ><figcaption>Static Page 1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/01/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week5/Result1.jpeg"
                      alt="CGI Page 1" title="CGI生成网页1"
                ><figcaption>CGI Page 1</figcaption></figure></p>
<h5 id="浏览器测试（表单未填写）"><a href="#浏览器测试（表单未填写）" class="headerlink" title="浏览器测试（表单未填写）"></a>浏览器测试（表单未填写）</h5><p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/01/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week5/Login2.jpeg"
                      alt="Static Page 2" title="静态网页2"
                ><figcaption>Static Page 2</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/01/Socket%E7%BC%96%E7%A8%8B%E8%AE%B0%E5%BD%95-Week5/Result2.jpeg"
                      alt="CGI Page 2" title="CGI生成网页2"
                ><figcaption>CGI Page 2</figcaption></figure></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>接触、了解了CGI程序及其功能，明白了如何根据用户的填写动态生成网页，以实现多样的应用层功能。</p>
]]></content>
      <categories>
        <category>计算机网络课程设计</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>TJUOJ 4441: 合并果子（堆）</title>
    <url>/2023/09/15/tjuoj-4441-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<p>补程设课，没什么事干，就在学校OJ上找了道<a class="link"   href="http://tjuacm.chaosheng.top/problem.php?id=4441" >简单题</a>做<br>算法复健一下，顺便试一试代码块插入</p>
<p>题目给了提示，应该是道堆排序的题<br>由于每次体力增加值为当前已合并果子的总数，因此我们只需保证每次合并的两个堆都是当前果子数量最少的两个堆即可<br>思路有些像霍夫曼编码，但题目只要求求最终的体力消耗，所以没有构建霍夫曼树的必要<br>准备直接做一个最小堆，每次合并操作都取两次堆顶元素，将求出的和累加至totalCost变量中，并放回堆里<br>循环至只剩一个元素时，totalCost中值即是所求答案</p>
<p><strong>理论存在，实践开始</strong></p>
<h2 id="Input-Init"><a href="#Input-Init" class="headerlink" title="Input &amp;&amp; Init"></a>Input &amp;&amp; Init</h2><p>首先进行数据读入和建堆操作<br>使用scanf读入数据增加速度<br>然后偷个懒，用 <code>#include &lt;algorithem&gt;</code> 的make_heap函数建堆<br><strong>需要注意，题中给出的数据最大可能为n&#x3D;30000，且每项均为20000</strong><br><strong>因此结果最大可能为2e4至6e8的等差求和，即9e12左右</strong><br><strong>考虑到我们会将中间结果存在堆中，因此需要一个64位的堆和totalCost</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *heap;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">heap = <span class="keyword">new</span> <span class="type">uint64_t</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, heap + i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">make_heap</span>(heap, heap + N, greater&lt;&gt;());</span><br></pre></td></tr></table></figure></div>

<h2 id="Main-Algorithem"><a href="#Main-Algorithem" class="headerlink" title="Main Algorithem"></a>Main Algorithem</h2><p>现在编写主算法<br>每次从堆顶取两个数进行加和，随后将结果存入堆中，并累加totalCost，直至堆中只剩一个元素</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> totalCost = <span class="number">0</span>, currentCost;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mergeTimes = N - <span class="number">1</span>; mergeTimes &gt; <span class="number">0</span>; mergeTimes--) &#123;</span><br><span class="line">    currentCost = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[mergeTimes];</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line"></span><br><span class="line">    currentCost += heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = currentCost;</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line">    </span><br><span class="line">    totalCost += currentCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Quoting-Function"><a href="#Quoting-Function" class="headerlink" title="Quoting Function"></a>Quoting Function</h2><p>最后实现用于维护堆的<code>maintainHeap</code>函数<br>我们只需跟踪堆顶元素，并循环判断判断它和它最小孩子的大小关系，若大于则与之交换并继续循环，否则返回</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find the minimum element in heap[i]&#x27;s children</span></span><br><span class="line"><span class="comment">//Return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinChild</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> parentIndex, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">2</span> &lt; length)</span><br><span class="line">        <span class="keyword">return</span> heap[(parentIndex * <span class="number">2</span>) + <span class="number">1</span>] &lt; heap[(parentIndex * <span class="number">2</span>) + <span class="number">2</span>] ? (parentIndex * <span class="number">2</span>) + <span class="number">1</span> : (parentIndex * <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">1</span> &lt; length)</span><br><span class="line">        <span class="built_in">return</span> (parentIndex * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maintain the heap as a minimum heap after changing the top</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainHeap</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = <span class="number">0</span>, minChildIndex;</span><br><span class="line">    </span><br><span class="line">    minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    <span class="keyword">while</span> (heap[parentIndex] &gt; heap[minChildIndex] &amp;&amp; minChildIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = heap[parentIndex];</span><br><span class="line">        heap[parentIndex] = heap[minChildIndex];</span><br><span class="line">        heap[minChildIndex] = temp;</span><br><span class="line">        </span><br><span class="line">        parentIndex = minChildIndex;</span><br><span class="line">        minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>至此编程结束，成功AC</strong></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>algorithem</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Lab1: 产生式动物识别系统</title>
    <url>/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>产生式识别系统通过一个规则库对特征进行识别，并推断出结果。<br>系统首先输入读入一些已知特征，随后根据规则库中的规则不断尝试推断出新的特征，直至最终得到结果，或是发现无法推出结果。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/rules.jpeg"
                      alt="rules" title="规则库"
                ><figcaption>rules</figcaption></figure><br>实验要求以上图规则库为基础，编写一个产生式动物识别系统。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/simple.jpg"
                      alt="simple" title="输出样例"
                ><figcaption>simple</figcaption></figure><br>如上图所示，要求程序首先输出所有可选特征，用户输入已知特征后，程序根据规则库进行推理，输出推理过程及最后的识别结果。</p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>算法本身很简单，正好最近在学python，试着用python写一写。</p>
<h4 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h4><p>我们先把所有特征存在一个数组里，以便后面推理过程的输出。<br>同时，我们按题目要求输出所有可选特征，并要求用户按序号进行输入。<br>最后，我们还需要根据特征序号存储所有的推理规则。推理规则都是由若干个特征推出一个新特征，一个键为向量、值为变量的键值对就可以很好的存储。<br>我们设键向量中的值为推理的前提特征，而值为推理得的新特征，根据实验所给的规则库一一编写即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h4><p>推理过程也很简单，我们只要写一个大循环，不断遍历所有规则，尝试寻找所有前提特征均已知且推出特征未知的规则，并将其推出特征加入已知特征即可。<br>需要注意，由于可能存在大序号特征推出小序号特征，进而导致出现新的可使用规则的情况，因此需要用while循环不断遍历，直至推得最终动物，或是没有任何一个规则可使用，即推理失败。循环嵌套比较多，也比较复杂，我也懒得对循环做拆分了，多设几个flag即可。<br>而在推理过程中，每当使用一个能推出新特征的规则，我们就用前面的特征数组输出该规则的前提特征和推出特征，即可实现中间过程的打印。<br>最终，我们输出系统的识别结果，代码如下。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>随便测了两个，一个推出企鹅，一个推不出来。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test1.jpeg"
                      alt="test1" title="测试样例1: 企鹅"
                ><figcaption>test1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/08/%E4%BA%A7%E7%94%9F%E5%BC%8F%E5%8A%A8%E7%89%A9%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F/test2.jpeg"
                      alt="test2" title="测试样例2: 无动物"
                ><figcaption>test2</figcaption></figure></p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>很简单，没啥总结的。<br>python语法真怪。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>最后放一下全部代码。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line">feature = [</span><br><span class="line">    <span class="string">&quot;空&quot;</span>, <span class="string">&quot;有毛发&quot;</span>, <span class="string">&quot;产奶&quot;</span>, <span class="string">&quot;有羽毛&quot;</span>, <span class="string">&quot;会飞&quot;</span>, <span class="string">&quot;会下蛋&quot;</span>,     <span class="comment"># 空用于占位</span></span><br><span class="line">    <span class="string">&quot;吃肉&quot;</span>, <span class="string">&quot;有犬齿&quot;</span>, <span class="string">&quot;有爪&quot;</span>, <span class="string">&quot;眼盯前方&quot;</span>, <span class="string">&quot;有蹄&quot;</span>,</span><br><span class="line">    <span class="string">&quot;反刍&quot;</span>, <span class="string">&quot;黄褐色&quot;</span>, <span class="string">&quot;有斑点&quot;</span>, <span class="string">&quot;有黑色条纹&quot;</span>, <span class="string">&quot;长脖&quot;</span>,</span><br><span class="line">    <span class="string">&quot;长腿&quot;</span>, <span class="string">&quot;不会飞&quot;</span>, <span class="string">&quot;会游泳&quot;</span>, <span class="string">&quot;黑白二色&quot;</span>, <span class="string">&quot;善飞&quot;</span>,</span><br><span class="line">    <span class="string">&quot;哺乳类&quot;</span>, <span class="string">&quot;鸟类&quot;</span>, <span class="string">&quot;食肉类&quot;</span>, <span class="string">&quot;蹄类&quot;</span>, <span class="string">&quot;金钱豹&quot;</span>,</span><br><span class="line">    <span class="string">&quot;虎&quot;</span>, <span class="string">&quot;长颈鹿&quot;</span>, <span class="string">&quot;斑马&quot;</span>, <span class="string">&quot;鸵鸟&quot;</span>, <span class="string">&quot;企鹅&quot;</span>, <span class="string">&quot;信天翁&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有动物特征如下:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*1:有毛发  2:产奶  3:有羽毛  4:会飞  5:会下蛋&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*6:吃肉  7:有犬齿  8:有爪  9:眼盯前方  10:有蹄&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*11:反刍  12:黄褐色  13:有斑点  14:有黑色条纹  15:长脖&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*16:长腿  17:不会飞  18:会游泳  19:黑白二色  20:善飞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*21:哺乳类  22:鸟类  23:食肉类  24:蹄类&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入数字选择动物的特征,结尾处用0:&quot;</span>)</span><br><span class="line"></span><br><span class="line">rules = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"><span class="comment"># 读入已知规则</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    rules[t] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则库</span></span><br><span class="line"><span class="keyword">match</span> = &#123;</span><br><span class="line">    (<span class="number">1</span>,): <span class="number">21</span>, (<span class="number">2</span>,): <span class="number">21</span>, (<span class="number">3</span>,): <span class="number">22</span>, (<span class="number">4</span>, <span class="number">5</span>): <span class="number">22</span>,</span><br><span class="line">    (<span class="number">6</span>,): <span class="number">23</span>, (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>): <span class="number">23</span>, (<span class="number">21</span>, <span class="number">9</span>): <span class="number">24</span>, (<span class="number">21</span>, <span class="number">11</span>): <span class="number">24</span>,</span><br><span class="line">    (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>): <span class="number">25</span>, (<span class="number">21</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">14</span>): <span class="number">26</span>, (<span class="number">24</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">13</span>): <span class="number">27</span>,</span><br><span class="line">    (<span class="number">24</span>, <span class="number">14</span>): <span class="number">28</span>, (<span class="number">22</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">29</span>, (<span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>): <span class="number">30</span>, (<span class="number">22</span>, <span class="number">20</span>): <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    check = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> v, res <span class="keyword">in</span> <span class="keyword">match</span>.items():</span><br><span class="line">        m = <span class="built_in">all</span>(rules[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> v)</span><br><span class="line">        <span class="keyword">if</span> res &lt; <span class="number">25</span> <span class="keyword">and</span> rules[res]:</span><br><span class="line">            m = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            check = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(feature[v[<span class="number">0</span>]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(v)):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span> + feature[v[i]], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; -&gt;&quot;</span>, feature[res])</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">25</span>:</span><br><span class="line">                rules[res] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = res</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> check:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ans:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该动物是:&quot;</span>, feature[ans])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法推理出该动物是什么&quot;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Lab2: 启发式搜索</title>
    <url>/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="一、实验要求"><a href="#一、实验要求" class="headerlink" title="一、实验要求"></a>一、实验要求</h2><p>这次实验要求我们用A算法求解八数码问题。<br>八数码问题是指，在一个3*3的棋盘上，存在8个棋子和1个空位，其中每个棋子都可以向上下左右四个方向移动（若存在空位）。给定一个初始状态和目标状态，要求找到从初始状态变换至目标状态的最短路径，输出步数和路径中的状态。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/8-puzzle.jpeg"
                      alt="8-puzzle" title="八数码问题"
                ><figcaption>8-puzzle</figcaption></figure><br>而启发式搜索算法则是一种状态空间树搜索算法。我们首先根据问题定义一个启发函数h，将h的值作为当前状态与目标状态之间的“差距”，用以判断当前状态的“好坏”。随后，我们对所有未扩展状态进行按估值h进行排序，每次都扩展当前最“好”的状态，直至找到目标状态，或是完全遍历状态空间树（无解）。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/algorithm.jpeg"
                      alt="heuristic-algorithm" title="启发式搜索"
                ><figcaption>heuristic-algorithm</figcaption></figure></p>
<h2 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h2><p>A算法最核心的地方就在于针对具体问题设计良好的启发函数h，剩下只需要用一个优先级队列存储所有未扩展状态，按h大小排序，挨个扩展并计算搜索深度（即步数）即可。因为这次实验要求我们给出结果路径的中间状态，所以还需要把已扩展节点也进行储存，并且在扩展过程中保留好路径信息。<br>估值函数上，这次实验给了四种h函数的备选，我们从中选择一个进行实现即可。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/h-function.jpeg"
                      alt="heuristic-function" title="启发函数"
                ><figcaption>heuristic-function</figcaption></figure><br>我选了曼哈顿距离和（启发函数二）作为启发函数，曼哈顿距离是指两个点坐标之间的绝对轴距之和，是一种很简单但很经典的启发函数。我们只需计算当前状态中每个点与目标状态中对应点的曼哈顿距离之和，便可以得到当前状态的估值h，h值越小代表状态与目标状态越接近，也就是状态越“好”。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/manhattan.jpeg"
                      alt="Manhattan-distance" title="曼哈顿距离"
                ><figcaption>Manhattan-distance</figcaption></figure><br>算法设计完成，下面就可以Coding了（这次还是用了C++）。</p>
<h4 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h4><p>首先是一些定义和初始化工作。定义状态结构体Node，存储对应的棋盘状态，估值h，步数depth。同时，因为对输出路径的要求，还需要存储状态id，以及其父状态parent，用于回溯求解路径。随后，我们需要定义用于优先级队列排序的比较函数，定义曼哈顿距离h更小的状态更优，而在h相等的情况下，我们应优先选择步数更少的状态。同时，我们定义存储未扩展节点的优先级队列open，用于回溯路径的已扩展节点序列close和路径path。最后，我们还需定义目标状态中各点的坐标。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>DEFINE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> h, depth;</span><br><span class="line">    <span class="type">int</span> id, parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.h &gt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.h &lt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.depth &gt; b.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.h最小堆</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; open;</span><br><span class="line">vector&lt;Node&gt; close;</span><br><span class="line">vector&lt;Node&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标状态</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 8 0 4</span></span><br><span class="line"><span class="comment">// 7 6 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end_loc[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="Manhattan-Distance"><a href="#Manhattan-Distance" class="headerlink" title="Manhattan Distance"></a>Manhattan Distance</h4><p>下面根据曼哈顿距离算法编写启发函数h。计算map中除0（即空位）外所有点与目标状态下的曼哈顿距离，并不断加和即可。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>ManhDis</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[i][j];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum += <span class="built_in">abs</span>(i - end_loc[num - <span class="number">1</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - end_loc[num - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Other-Functions"><a href="#Other-Functions" class="headerlink" title="Other Functions"></a>Other Functions</h4><p>随后再定义一些辅助函数。例如checkSame函数，用于检验当前状态是否在open或close序列中存在，以避免对状态的重复搜索。以及print_info函数（可选），用于在搜索过程中输出每次扩展的状态信息，辅助调试。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>HELPER</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在已搜索的相同状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSame</span><span class="params">(Node t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> same = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close[i].map[j][k] != t.map[j][k]) &#123;</span><br><span class="line">                    same = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (same)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;cur.map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id: &quot;</span>&lt;&lt;cur.id&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent: &quot;</span>&lt;&lt;cur.parent&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//depth</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;depth: &quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//h</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span>&lt;&lt;cur.h &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h4><p>下面进入main函数。首先是初始化部分，要求用户输入初始状态（以数字0表示空位），设置其相关信息，并将初始状态加入未扩展节点列表。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>INIT</span></figcaption><table><tr><td class="code"><pre><span class="line">Node start;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入初始状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        cin&gt;&gt;start.map[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start.h = <span class="built_in">H</span>(start.map);</span><br><span class="line">start.depth = <span class="number">0</span>;</span><br><span class="line">start.id = <span class="number">0</span>;</span><br><span class="line">start.parent = <span class="number">-1</span>;</span><br><span class="line">open.<span class="built_in">push</span>(start);</span><br></pre></td></tr></table></figure></div>

<h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><p>随后，开始对状态空间树的搜索。我们从open队列中取出最优的状态，检查其是否为目标状态（后续给出）后，尝试对其进行变换，搜索其子状态。对于状态的变换，虽然实际的定义是尝试让每个棋子向上下左右四个方向移动，但由于只有移动至空格位置才能变换成功，因此可以等效为尝试将空格进行上下左右四个方向（处于边界则移动失败）的移动。因此，我们可以分别尝试四种移动。对于每次变换后的子状态，我们首先更新其棋盘，并根据棋盘进行相同状态检索。若该状态已经检索过，则跳过。否则，我们应计算其估值，步数，id等信息，并记录其父状态的id，以便后续回溯求解路径。最后，我们将该状态加入未扩展状态队列open中，并继续搜索下一子状态。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>SEARCH</span></figcaption><table><tr><td class="code"><pre><span class="line">Node cur = open.<span class="built_in">top</span>();</span><br><span class="line">        open.<span class="built_in">pop</span>();</span><br><span class="line">        close.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print_info(cur);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x - <span class="number">1</span>][y];</span><br><span class="line">            next.map[x - <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历close表和open，若存在相同状态则跳过</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x + <span class="number">1</span>][y];</span><br><span class="line">            next.map[x + <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y - <span class="number">1</span>];</span><br><span class="line">            next.map[x][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y + <span class="number">1</span>];</span><br><span class="line">            next.map[x][y + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h4><p>前面提到，我们在取出一个未扩展状态后需要先检查其是否为目标状态，随后再进行扩展，现在就对检查进行讨论。当状态估值h为0时，代表状态为目标状态。因此，我们可以认定找到一个解，并输出步数和搜索空间（可指示算法运行时间）。而对于路径的回溯，我们需要从最终的状态开始，不断根据状态的parent属性，在close序列中查找id等于parent的状态，并将其加入path序列中。最后倒序输出path即为我们搜索到的求解路径。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CHECK</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur.h == <span class="number">0</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;找到解！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;步数：&quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;搜索空间：&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;路径：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">    <span class="keyword">while</span> (cur.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (close[i].id == cur.parent) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(close[i]);</span><br><span class="line">                cur = close[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第 &quot;</span> &lt;&lt;path.<span class="built_in">size</span>() - i - <span class="number">1</span> &lt;&lt;<span class="string">&quot; 步：\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout&lt;&lt;path[i].map[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span> &lt;&lt;path[i].h &lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="三、程序测试"><a href="#三、程序测试" class="headerlink" title="三、程序测试"></a>三、程序测试</h2><p>实验手册给出了两个测试样例，涵盖了步数较少和较多两种情况，我就直接拿来用了。<br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/test1.jpeg"
                      alt="test-1" title="测试样例1"
                ><figcaption>test-1</figcaption></figure><br><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/05/14/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/test2.jpeg"
                      alt="test-2" title="测试样例2"
                ><figcaption>test-2</figcaption></figure><br>第二个样例的路径较长，就不全放了。</p>
<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>这次实验的算法也比较简单，编码上搜索状态空间树的部分有点复杂，但难度也不大。而A算法最核心的就是启发函数的设计，实验直接给了4个函数备选，因此也没什么设计难度，编码实现即可。</p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p>最后放一下全部代码。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> h, depth;</span><br><span class="line">    <span class="type">int</span> id, parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.h &gt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.h &lt; b.h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.depth &gt; b.depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.h最小堆</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; open;</span><br><span class="line">vector&lt;Node&gt; close;</span><br><span class="line">vector&lt;Node&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标状态</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// 8 0 4</span></span><br><span class="line"><span class="comment">// 7 6 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end_loc[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前状态的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(<span class="type">int</span> map[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> num = map[i][j];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum += <span class="built_in">abs</span>(i - end_loc[num - <span class="number">1</span>][<span class="number">0</span>]) + <span class="built_in">abs</span>(j - end_loc[num - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否存在已搜索的相同状态</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSame</span><span class="params">(Node t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> same = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (close[i].map[j][k] != t.map[j][k]) &#123;</span><br><span class="line">                    same = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (same)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cout&lt;&lt;cur.map[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//id</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id: &quot;</span>&lt;&lt;cur.id&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent: &quot;</span>&lt;&lt;cur.parent&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//depth</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;depth: &quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//h</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span>&lt;&lt;cur.h &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node start;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入初始状态：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;start.map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start.h = <span class="built_in">H</span>(start.map);</span><br><span class="line">    start.depth = <span class="number">0</span>;</span><br><span class="line">    start.id = <span class="number">0</span>;</span><br><span class="line">    start.parent = <span class="number">-1</span>;</span><br><span class="line">    open.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!open.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node cur = open.<span class="built_in">top</span>();</span><br><span class="line">        open.<span class="built_in">pop</span>();</span><br><span class="line">        close.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// print_info(cur);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.h == <span class="number">0</span>) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;找到解！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;步数：&quot;</span>&lt;&lt;cur.depth&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;搜索空间：&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;路径：&quot;</span>&lt;&lt;endl;</span><br><span class="line">            path.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">while</span> (cur.parent != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; close.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (close[i].id == cur.parent) &#123;</span><br><span class="line">                        path.<span class="built_in">push_back</span>(close[i]);</span><br><span class="line">                        cur = close[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;第 &quot;</span> &lt;&lt;path.<span class="built_in">size</span>() - i - <span class="number">1</span> &lt;&lt;<span class="string">&quot; 步：\n&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                        cout&lt;&lt;path[i].map[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;曼哈顿距离：&quot;</span> &lt;&lt;path[i].h &lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x - <span class="number">1</span>][y];</span><br><span class="line">            next.map[x - <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历close表和open，若存在相同状态则跳过</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x + <span class="number">1</span>][y];</span><br><span class="line">            next.map[x + <span class="number">1</span>][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y - <span class="number">1</span>];</span><br><span class="line">            next.map[x][y - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            Node next = cur;</span><br><span class="line">            next.map[x][y] = cur.map[x][y + <span class="number">1</span>];</span><br><span class="line">            next.map[x][y + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            flag = <span class="built_in">checkSame</span>(next);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                next.h = <span class="built_in">H</span>(next.map);</span><br><span class="line">                next.depth = cur.depth + <span class="number">1</span>;</span><br><span class="line">                next.id = ++count;</span><br><span class="line">                next.parent = cur.id;</span><br><span class="line">                open.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>人工智能基础实验</category>
      </categories>
      <tags>
        <tag>TJU CS Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>转智算机试直通车-1</title>
    <url>/2024/05/19/%E8%BD%AC%E6%99%BA%E7%AE%97%E6%9C%BA%E8%AF%95%E7%9B%B4%E9%80%9A%E8%BD%A6-1/</url>
    <content><![CDATA[
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-circle-info"></i><p>宇宙安全声明</p>

    </div>
    <div class="notel-content">
      <p>本博客中所出现往年题目均来<a class="link"   href="https://wiki.tjubot.cn/major-changing/to-cic" >北洋维基</a>的学长分享，不一定代表真实机试题目。此外，本人并非算法竞赛选手，且不掌握任何关于转专业机试的额外信息，因此本博客的任何内容均不构成备考建议，仅为算法分享。最后，由于本人水平有限，不保证题解绝对正确，如有任何错误或问题欢迎与我联系（QQ：2827924832）。</p>

    </div>
  </div>

<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>考虑到最近几年的转智算的机试难度越来越高，且仍有继续上升的趋势，同时很多同学可能对OJ题目不太熟悉，不知道复习从何下手。因此萌生出写一篇机试往年题解的想法，为大家复习往年机试题的时候提供一点参考，也希望可以对大家的备考之路有一定的帮助。本博客预计会有5篇，覆盖21-24年四年的机试真题，并在最后给出几道对明年机试题的简单预测。不过最终更新情况还要取决于我的懒惰程度(bushi。</p>
<h2 id="关于头文件"><a href="#关于头文件" class="headerlink" title="关于头文件"></a>关于头文件</h2><p>首先，由于机试时间有限，因此推荐各位在编程时引用合适的头文件，多使用已有库辅助编程，不仅能提升编程效率，还能简化代码，减少错误，十分滴珍贵。<br>据我的经验，我们学校的OJ系统是支持万能头的，所以只需在程序开始处声明如下语句，便能解决一切头文件问题。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>万能头</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>不过，如果你因为各种原因无法使用万能头，以下是一些常用头文件的集合。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>常用头文件</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h2 id="关于复杂度"><a href="#关于复杂度" class="headerlink" title="关于复杂度"></a>关于复杂度</h2><p>复杂度的相关知识和分析技巧在数据结构课程中应该会有所提及，因此在这里就不再详细展开了。在练习过程中，有些题目可能会对程序的运行时间或运行所需内存空间有所限制（也就是常说的TLE和MLE错误），因此对于较复杂的问题，你需要具备判断自己的程序能否满足题目限制的能力（天大OJ题目的限制普遍为时间1s，内存256MB）。内存大小的判断需要根据实际使用的不同数据类型进行计算，而对于时间长短的判断，只需要在分析完复杂度后记住：<br><b>1 s &#x3D; 10^9 次运算</b></p>
<h2 id="2021年题目解析"><a href="#2021年题目解析" class="headerlink" title="2021年题目解析"></a>2021年题目解析</h2><p>近几年的机试题目难度显著的随年份上涨而增加，因此直接按年份顺序复习即可。此外，21年的题目都很简单，如果对已经有一定的上机练习经验可以跳过此博客。</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>输入一组整数，输出其中的最大值和最小值。<br>注：数据量很大。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这题简单易懂，要求一组数据中的最大值和最小值。因此，只需将所有数据读入，并不断记录已读入数据的最大值和最小值即可。但需要注意，由于需要读入的数据量可能极大，而cin&#x2F;cout的数据读写速度要显著慢于scanf&#x2F;printf，因此此题最好使用scanf来进行数据的读入。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>A</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 数据量N</span></span><br><span class="line">    <span class="type">int</span> max, min;   <span class="comment">// 用于记录已读入数据的最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 用于读入数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max);</span><br><span class="line">    min = max;  <span class="comment">// 初始化max和min为第一个数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);    <span class="comment">// 读入数据</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; max)</span><br><span class="line">            max = x;    <span class="comment">// 更新当前max</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; min)</span><br><span class="line">            min = x;    <span class="comment">// 更新当前min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max: %d\nMin: %d\n&quot;</span>, max, min);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>输入两个整数，判断两数的最大公因数。<br>注：数据值很大。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这道题由于传入的数据可能很大，直接暴力搜索求解可能会时间超限，因此需要使用辗转相除法求解。这种题其实讲解的意义不大，就是考察你知不知道这种算法。但辗转相除法实在太过经典，所以还是很有必要记一下的。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>B</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);   <span class="comment">// 递归计算gcd(y, x mod y)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;   <span class="comment">// 当y为零时，x即为最小公因数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    cin&gt;&gt;x &gt;&gt;y;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(x, y) &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>首先输入一个整数，后面跟有多行输入，每行输入一个操作符(<code>+ - *</code>)和第二个操作数。<br>对于每行输入，输出运算后结果。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这道题本身是一道很简单的模拟题，只需按题目要求对每组输入的操作符进行switch判断，然后运算即可。但在北洋维基的题目要求中并没有明确指出如何进行多行输入，因此我这里假定为不预先给出行数N，也不给出跳出条件的输入方式。<br>对于这种无法判断何时结束的多行输入，我们只需通过while循环不断检测是否有下一组数据输入即可。由于OJ的判题方式是通过文件向程序输入，再将输出与结果文件进行比对，因此在输入结束处会读入一个<code>EOF</code>标志符，代表文件结尾。而对于<code>EOF</code>输入，<code>cin</code>函数会返回0，因此类似如下的语句就能顺利对组数未知的多组输入进行正确处理。<br><code>while(cin&gt;&gt;var) {}</code><br>据此，我们就能顺利解答本题。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>C</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:           <span class="comment">// 这里直接return，所以不需要break</span></span><br><span class="line">            <span class="keyword">return</span> a + b;   <span class="comment">// 其它情况下switch语句记得写break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>, &amp;op, &amp;b)) &#123;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        a = <span class="built_in">cal</span>(a, b, op);</span><br><span class="line">        cout&lt;&lt;a &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>根据题目给出的判断条件，输入一个年份，判断其是否是闰年。</p>

    </div>
  </div>
<p>完全依赖题目给出条件的<code>if else</code>题，分享里也没有具体条件，因此不做解答。<br>猜测此题目和生环OJ上的 <a class="link"   href="https://tjucpp.top/problem.php?id=1025" >1025: 判断闰年I</a> 一样，实在想做可以去尝试一下。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-bolt"></i><p>题目描述</p>

    </div>
    <div class="notel-content">
      <p>读入两个长度为10的字符串，取第一个字符串的前五个字符和第二个字符串的后五个字符，拼接为一个新串并输出。</p>

    </div>
  </div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>题解及答案 </summary>
              <div class='content'>
              <p>这道题的难度依旧不大，也不需要很多算法上的技巧，逐字符操作即可，只需注意字符串最后的结束符<code>\0</code>即可。<br>不过，借助此题，推荐大家熟悉一些字符串操作的常用函数，如<code>strlen</code>、<code>strcmp</code>、<code>strcat</code>等。此外，对于字符串相关的题目，我建议大家尽量使用<code>string</code>完成，可以在很大程度上避免对结束符操作不当等产生的错误，并且相关的函数也较为简单（此题用<code>char</code>数组更方便，因此不用<code>string</code>实现）。<br>我的答案如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>E</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">11</span>], b[<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;a &gt;&gt;b &gt;&gt;b;     <span class="comment">// 丢弃b串的前五个字符，只需要后五个</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(a + <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>);    <span class="comment">// 覆盖a串后五个字符，只需要前五个</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(a, b);   <span class="comment">// 将b（b串后五个字符）拼接在a（a串前五个字符）后</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>21级题目难度很小，可能还不及C++课程的上机作业题目，比较适合先前完全没有接触过C++程序设计的同学。后续22、23年的最后两题难度应该会有所提升。</p>
<p><b>持续更新中……</b></p>
]]></content>
      <categories>
        <category>转智算机试直通车</category>
      </categories>
      <tags>
        <tag>algorithem</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="WELCOME-TO-MY-BLOG"><a href="#WELCOME-TO-MY-BLOG" class="headerlink" title="WELCOME TO MY BLOG"></a>WELCOME TO MY BLOG</h1><h3 id="BY-MENGMAO-REINE"><a href="#BY-MENGMAO-REINE" class="headerlink" title="BY MENGMAO REINE"></a>BY MENGMAO REINE</h3><h5 id="天津大学CS本科在读，随机掉落一些课程实验记录、算法笔记和旅拍照片。"><a href="#天津大学CS本科在读，随机掉落一些课程实验记录、算法笔记和旅拍照片。" class="headerlink" title="天津大学CS本科在读，随机掉落一些课程实验记录、算法笔记和旅拍照片。"></a>天津大学CS本科在读，随机掉落一些课程实验记录、算法笔记和旅拍照片。</h5><p>如果你想看一些实验记录 <a href="https://mengmaor.github.io/tags/TJU-CS-Lab/">Click here</a><br>如果你想看一些算法笔记 <a href="https://mengmaor.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Click here</a><br>如果你想转入智算 <a href="https://mengmaor.github.io/categories/%E8%BD%AC%E6%99%BA%E7%AE%97%E6%9C%BA%E8%AF%95%E7%9B%B4%E9%80%9A%E8%BD%A6/">Click here</a><br>如果你想看看我的旅拍记忆 <a href="https://mengmaor.github.io/masonry/">Click here</a></p>
<p><b>HERE WE ARE</b></p>
<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/pale_blue_dot.jpeg"
                      alt="Pale Blue Dot" title="暗淡蓝点"
                ><figcaption>Pale Blue Dot</figcaption></figure></p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>here’s categories</p>
]]></content>
  </entry>
  <entry>
    <title>时光博物馆</title>
    <url>/masonry/index.html</url>
    <content><![CDATA[<hr>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-ticket-airline"></i><p>记忆收录</p>

    </div>
    <div class="notel-content">
      <ol>
<li>阿那亚 2022.2.22 - 2022.2.26</li>
<li>日本 2024.2.14 - 2024.2.21</li>
</ol>

    </div>
  </div>]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<p>here’s tags</p>
]]></content>
  </entry>
</search>
