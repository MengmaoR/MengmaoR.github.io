<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/13/Hello/</url>
    <content><![CDATA[<p>Here’s my first BLOG<br>So let’s say</p>
<p><strong>Hello World!</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Image test</title>
    <url>/2023/09/14/Image-test/</url>
    <content><![CDATA[<p>Try to post a pic</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test-pic.png"
                      class="" title="test1"
                >

<p><figure class="image-caption"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/14/Image-test/test2.jpeg"
                      alt="test-pic2" title="test2"
                ><figcaption>test-pic2</figcaption></figure></p>
<p>Test end</p>
]]></content>
      <categories>
        <category>Function Test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>TJUOJ 4441: 合并果子（堆）</title>
    <url>/2023/09/15/tjuoj-4441-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<p>补程设课，没什么事干，就在学校OJ上找了道<a class="link"   href="http://tjuacm.chaosheng.top/problem.php?id=4441" >简单题</a>做<br>算法复健一下，顺便试一试代码块插入</p>
<p>题目给了提示，应该是道堆排序的题<br>由于每次体力增加值为当前已合并果子的总数，因此我们只需保证每次合并的两个堆都是当前果子数量最少的两个堆即可<br>思路有些像霍夫曼编码，但题目只要求求最终的体力消耗，所以没有构建霍夫曼树的必要<br>准备直接做一个最小堆，每次合并操作都取两次堆顶元素，将求出的和累加至totalCost变量中，并放回堆里<br>循环至只剩一个元素时，totalCost中值即是所求答案</p>
<p><strong>理论存在，实践开始</strong></p>
<h2 id="Input-Init"><a href="#Input-Init" class="headerlink" title="Input &amp;&amp; Init"></a>Input &amp;&amp; Init</h2><p>首先进行数据读入和建堆操作<br>使用scanf读入数据增加速度<br>然后偷个懒，用 <code>#include &lt;algorithem&gt;</code> 的make_heap函数建堆<br><strong>需要注意，题中给出的数据最大可能为n&#x3D;30000，且每项均为20000</strong><br><strong>因此结果最大可能为2e4至6e8的等差求和，即9e12左右</strong><br><strong>考虑到我们会将中间结果存在堆中，因此需要一个64位的堆和totalCost</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> *heap;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">heap = <span class="keyword">new</span> <span class="type">uint64_t</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, heap + i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">make_heap</span>(heap, heap + N, greater&lt;&gt;());</span><br></pre></td></tr></table></figure></div>

<h2 id="Main-Algorithem"><a href="#Main-Algorithem" class="headerlink" title="Main Algorithem"></a>Main Algorithem</h2><p>现在编写主算法<br>每次从堆顶取两个数进行加和，随后将结果存入堆中，并累加totalCost，直至堆中只剩一个元素</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">uint64_t</span> totalCost = <span class="number">0</span>, currentCost;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mergeTimes = N - <span class="number">1</span>; mergeTimes &gt; <span class="number">0</span>; mergeTimes--) &#123;</span><br><span class="line">    currentCost = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[mergeTimes];</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line"></span><br><span class="line">    currentCost += heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = currentCost;</span><br><span class="line">    <span class="built_in">maintainHeap</span>(heap, mergeTimes);</span><br><span class="line">    </span><br><span class="line">    totalCost += currentCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Quoting-Function"><a href="#Quoting-Function" class="headerlink" title="Quoting Function"></a>Quoting Function</h2><p>最后实现用于维护堆的<code>maintainHeap</code>函数<br>我们只需跟踪堆顶元素，并循环判断判断它和它最小孩子的大小关系，若大于则与之交换并继续循环，否则返回</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><figcaption><span>CODE</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find the minimum element in heap[i]&#x27;s children</span></span><br><span class="line"><span class="comment">//Return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinChild</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> parentIndex, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">2</span> &lt; length)</span><br><span class="line">        <span class="keyword">return</span> heap[(parentIndex * <span class="number">2</span>) + <span class="number">1</span>] &lt; heap[(parentIndex * <span class="number">2</span>) + <span class="number">2</span>] ? (parentIndex * <span class="number">2</span>) + <span class="number">1</span> : (parentIndex * <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((parentIndex * <span class="number">2</span>) + <span class="number">1</span> &lt; length)</span><br><span class="line">        <span class="built_in">return</span> (parentIndex * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maintain the heap as a minimum heap after changing the top</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainHeap</span><span class="params">(<span class="type">uint64_t</span>* heap, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parentIndex = <span class="number">0</span>, minChildIndex;</span><br><span class="line">    </span><br><span class="line">    minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    <span class="keyword">while</span> (heap[parentIndex] &gt; heap[minChildIndex] &amp;&amp; minChildIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = heap[parentIndex];</span><br><span class="line">        heap[parentIndex] = heap[minChildIndex];</span><br><span class="line">        heap[minChildIndex] = temp;</span><br><span class="line">        </span><br><span class="line">        parentIndex = minChildIndex;</span><br><span class="line">        minChildIndex = <span class="built_in">findMinChild</span>(heap, parentIndex, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>至此编程结束，成功AC</strong></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>algorithem</tag>
      </tags>
  </entry>
  <entry>
    <title>the Park 游戏框架</title>
    <url>/2023/10/16/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="建造模块"><a href="#建造模块" class="headerlink" title="建造模块"></a>建造模块</h1><h2 id="正交俯视建造"><a href="#正交俯视建造" class="headerlink" title="正交俯视建造"></a>正交俯视建造</h2><p>建筑整体框架<br>建筑构造<br>内部装饰</p>
<div class="note-large blue"><div class="notel-title"><p>允许三种建造模式</p>
</div><div class="notel-content"><ol>
<li>快速建造</li>
<li>专业建造</li>
<li>模型或代码导入</li>
</ol>
</div></div>

<h3 id="快速建造"><a href="#快速建造" class="headerlink" title="快速建造"></a>快速建造</h3><ol>
<li>通过level up&#x2F;down 按键进行层数调整</li>
<li>墙壁和地板全部采用模块化网格建造<details class="" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>3. 内饰随意放置 </summary>
              <div class='content'>
              <p>禁止模型重叠<br>允许模型重叠</p>
              </div>
            </details></li>
</ol>
<h3 id="专业建造"><a href="#专业建造" class="headerlink" title="专业建造"></a>专业建造</h3><ol>
<li>通过level up&#x2F;down 按键进行层数调整</li>
<li>允许调整每层高度</li>
<li>允许墙壁纵向倾斜<details class="" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>4. 允许自定义地板轮廓 </summary>
              <div class='content'>
              <p>网格辅助下的矩形选区<br>无辅助的图形选区<br>铅笔绘图</p>
              </div>
            </details>
<details class="" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>5. 内饰随意放置 </summary>
              <div class='content'>
              <p>禁止模型重叠<br>允许模型重叠</p>
              </div>
            </details></li>
<li>允许室内空间拓展</li>
</ol>
<h3 id="模型或代码导入"><a href="#模型或代码导入" class="headerlink" title="模型或代码导入"></a>模型或代码导入</h3><ol>
<li>模型导入</li>
<li>放置(拟)代码导入</li>
</ol>
<p>后续再做具体构思</p>
<h2 id="3D第一人称视角修改"><a href="#3D第一人称视角修改" class="headerlink" title="3D第一人称视角修改"></a>3D第一人称视角修改</h2><ol>
<li>效果预览</li>
<li>内饰调整</li>
</ol>
<h2 id="自定义游戏构建"><a href="#自定义游戏构建" class="headerlink" title="自定义游戏构建"></a>自定义游戏构建</h2><p>后续构思</p>
<h1 id="地图模块"><a href="#地图模块" class="headerlink" title="地图模块"></a>地图模块</h1><h2 id="主岛"><a href="#主岛" class="headerlink" title="主岛"></a>主岛</h2><ol>
<li>中心为出生点公园</li>
<li>公园内部和四周为提前搭建的建筑设施和预留地</li>
<li>外部地形自动生成<details class="" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>4. 外部土地按序分配给玩家 </summary>
              <div class='content'>
              <p>创建账号自动分配面积固定土地，可自由选择位置<br>已分配土地可通过官方自由交易<br>未探索土地可通过官方低价购买<br>已购土地长时间不进行有效开发将被强制回购，已获取的资源不会回收</p>
              </div>
            </details></li>
<li>允许在已拥有土地，官方土地和交通路线范围内任意传送</li>
<li>生存玩法</li>
</ol>
<h2 id="狩猎岛"><a href="#狩猎岛" class="headerlink" title="狩猎岛"></a>狩猎岛</h2><ol>
<li>土地无法获取和开发</li>
<li>无法传送</li>
<li>战斗玩法</li>
<li>其余规则后续构思</li>
</ol>
<h2 id="玩家岛"><a href="#玩家岛" class="headerlink" title="玩家岛"></a>玩家岛</h2><ol>
<li>允许部分玩家自定义岛屿</li>
<li>自定义玩法</li>
<li>其余规则后续构思</li>
</ol>
<h1 id="玩法模块"><a href="#玩法模块" class="headerlink" title="玩法模块"></a>玩法模块</h1><h2 id="生存玩法"><a href="#生存玩法" class="headerlink" title="生存玩法"></a>生存玩法</h2><ol>
<li>野外开荒</li>
<li>材料收集</li>
<li>少量战斗元素</li>
<li>有限大小随机生成地图</li>
</ol>
<h2 id="创作玩法"><a href="#创作玩法" class="headerlink" title="创作玩法"></a>创作玩法</h2><ol>
<li>利用所获取的资源进行模型创作</li>
<li>绘画</li>
<li>武器锻造</li>
<li>饰品、服装设计</li>
<li>家具、内饰、墙壁等建筑设计</li>
<li>模型导入(需消耗货币)</li>
<li>创作需在特定场所或设施内</li>
</ol>
<h2 id="战斗玩法"><a href="#战斗玩法" class="headerlink" title="战斗玩法"></a>战斗玩法</h2><ol>
<li>PVE战斗</li>
<li>其余规则后续构思</li>
</ol>
<h2 id="自定义玩法"><a href="#自定义玩法" class="headerlink" title="自定义玩法"></a>自定义玩法</h2><ol>
<li>玩家自行设计</li>
<li>通过内置设计器设计或外部设计并导入</li>
<li>其余规则后续构思</li>
</ol>
<h1 id="资产模块"><a href="#资产模块" class="headerlink" title="资产模块"></a>资产模块</h1><h2 id="资产获取"><a href="#资产获取" class="headerlink" title="资产获取"></a>资产获取</h2><ol>
<li>从生存岛屿获取资源并售卖给官方，获得货币资产</li>
<li>参与相关活动，获得官方发放的货币资产或徽章、雕像等模型资产</li>
<li>利用获取或购买的资产创作，产生模型资产</li>
<li>通过与玩家间的交易获取货币或模型资产</li>
</ol>
<h2 id="资产持有"><a href="#资产持有" class="headerlink" title="资产持有"></a>资产持有</h2><ol>
<li>模型资产不可分割，只能作为整体持有</li>
<li>玩家拥有的资源、货币和人物模型将合并为角色资产持有</li>
<li>玩家可以小规模负债，但负债过多将被强制进入破产程序</li>
</ol>
<h2 id="资产交易"><a href="#资产交易" class="headerlink" title="资产交易"></a>资产交易</h2><ol>
<li>提供两种交易协议：使用和买断</li>
<li>使用 使用 协议交易的资产可以在买家的土地内放置，用于创作新资产并在买家的土地上放置</li>
<li>使用 买断 协议交易的资产，买家可以享受 使用 协议的全部权利，同时可以用于创作新资产并将该资产用于交易，且卖家对该资产的权利变为 使用 协议包含的权利</li>
<li>允许玩家对单个交易自行编写交易协议</li>
<li>详细规则后续构思</li>
</ol>
<h2 id="玩家社交"><a href="#玩家社交" class="headerlink" title="玩家社交"></a>玩家社交</h2><ol>
<li>玩家可以在自己的土地上设置其他玩家的权限</li>
<li>玩家在主岛上非特殊区域内被禁止相互伤害</li>
<li>玩家可以自定义自己岛屿上的玩家规则</li>
<li>玩家被禁止在未经允许的情况下进入他人土地</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>here’s about page</p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>here’s categories</p>
]]></content>
  </entry>
  <entry>
    <title>Photos</title>
    <url>/masonry/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[<p>here’s tags</p>
]]></content>
  </entry>
</search>
